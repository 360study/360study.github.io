"use strict";(self.webpackChunkdocusaurus_test=self.webpackChunkdocusaurus_test||[]).push([[9314],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var h=n.createContext({}),l=function(e){var t=n.useContext(h),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(h.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,h=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(a),c=o,u=d["".concat(h,".").concat(c)]||d[c]||m[c]||r;return a?n.createElement(u,i(i({ref:t},p),{},{components:a})):n.createElement(u,i({ref:t},p))}));function u(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=c;var s={};for(var h in t)hasOwnProperty.call(t,h)&&(s[h]=t[h]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},85132:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var n=a(87462),o=(a(67294),a(3905));const r={},i="Mastering Lookahead and Lookbehind",s={unversionedId:"\u4e2a\u4eba\u8d44\u6599/1",id:"\u4e2a\u4eba\u8d44\u6599/1",title:"Mastering Lookahead and Lookbehind",description:"[![Page copy protected against web site content",source:"@site/docs/\u4e2a\u4eba\u8d44\u6599/1.mdx",sourceDirName:"\u4e2a\u4eba\u8d44\u6599",slug:"/\u4e2a\u4eba\u8d44\u6599/1",permalink:"/\u4e2a\u4eba\u8d44\u6599/1",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"0\u3001\u5f15\u8a00",permalink:"/\u4e2a\u4eba\u8d44\u6599/0\u3001\u5f15\u8a00"},next:{title:"\u6b63\u5219\u8868\u8fbe\u5f0f",permalink:"/\u4e2a\u4eba\u8d44\u6599/\u6b63\u5219\u8868\u8fbe\u5f0f"}},h={},l=[{value:"Lookahead Example: Simple Password Validation",id:"lookahead-example-simple-password-validation",level:2},{value:"The Order of Lookaheads Doesn&#39;t Matter\u2026 Almost",id:"the-order-of-lookaheads-doesnt-matter-almost",level:2},{value:"Lookarounds Stand their Ground",id:"lookarounds-stand-their-ground",level:2},{value:"Various Uses for Lookarounds",id:"various-uses-for-lookarounds",level:2},{value:"Zero-Width Matches",id:"zero-width-matches",level:2},{value:"Positioning the Lookaround",id:"positioning-the-lookaround",level:2},{value:"Lookarounds that Look on Both Sides: Back to the Future",id:"lookarounds-that-look-on-both-sides-back-to-the-future",level:2},{value:"Compound Lookahead and Compound Lookbehind",id:"compound-lookahead-and-compound-lookbehind",level:2},{value:"The Engine Doesn&#39;t Backtrack into Lookarounds\u2026",id:"the-engine-doesnt-backtrack-into-lookarounds",level:2},{value:"Fixed-Width, Constrained-Width and Infinite-Width Lookbehind",id:"fixed-width-constrained-width-and-infinite-width-lookbehind",level:2},{value:"Lookarounds (Usually) Want to be Anchored",id:"lookarounds-usually-want-to-be-anchored",level:2},{value:"Footnotes",id:"footnotes",level:2}],p={toc:l},d="wrapper";function m(e){let{components:t,...a}=e;return(0,o.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mastering-lookahead-and-lookbehind"},"Mastering Lookahead and Lookbehind"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"http://www.copyscape.com/"},(0,o.kt)("img",{parentName:"a",src:"https://d1go27vtttaqyn.cloudfront.net/copyscape-white.gif",alt:"Page copy protected against web site content\ninfringement by Copyscape",title:"Do not copy content from the page.\nPlagiarism will be detected by Copyscape."}))),(0,o.kt)("p",null,"Lookarounds often cause confusion to the regex apprentice. I believe this confusion promptly disappears if one simple point is firmly grasped. It is that at the end of a lookahead or a lookbehind, the regex engine hasn't moved on the string. You can chain three more lookaheads after the first, and the regex engine still won't move. In fact, that's a useful technique.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"A quick syntax reminder"),(0,o.kt)("br",{parentName:"p"}),"\n","This page digs deep into the details of lookahead and lookbehind and assumes you've already become familiar with the basic syntax, perhaps by reading the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-disambiguation.html#lookarounds"},"lookaround section"),"\xa0of the reference on\xa0(? \u2026 )\xa0syntax. As a quick reminder before we dive in, here are the four lookarounds.  "),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"}," Lookaround \t")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Name ")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"What it Does")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"(?=foo)"),(0,o.kt)("td",{parentName:"tr",align:null},"Lookahead"),(0,o.kt)("td",{parentName:"tr",align:null},"Asserts that what immediately follows the current position in the string is foo")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"(?<=foo)"),(0,o.kt)("td",{parentName:"tr",align:null},"Lookbehind"),(0,o.kt)("td",{parentName:"tr",align:null},"Asserts that what immediately precedes the current position in the string is foo")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"(?!foo)"),(0,o.kt)("td",{parentName:"tr",align:null},"Negative Lookahead"),(0,o.kt)("td",{parentName:"tr",align:null},"Asserts that what immediately follows the current position in the string is not foo")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"(?<!foo)"),(0,o.kt)("td",{parentName:"tr",align:null},"Negative Lookbehind"),(0,o.kt)("td",{parentName:"tr",align:null},"Asserts that what immediately precedes the current position in the string is not foo")))),(0,o.kt)("p",null,"Lookaround\tName\tWhat it Does\n(?=foo)\tLookahead\tAsserts that what immediately follows the current position in the string is foo\n(?<=foo)\tLookbehind\tAsserts that what immediately precedes the current position in the string is foo\n(?!foo)\tNegative Lookahead\tAsserts that what immediately follows the current position in the string is not foo\n(?<!foo)\tNegative Lookbehind\tAsserts that what immediately precedes the current position in the string is not foo"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#nav"},"(direct link)"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Jumping Points"),(0,o.kt)("br",{parentName:"p"}),"\n","For easy navigation, here are some jumping points to various sections of the page:  "),(0,o.kt)("p",null,"\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#password"},"Lookahead Example: Simple Password Validation"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#order"},"The Order of Lookaheads Doesn't Matter\u2026 Almost"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#stand_their_ground"},"Lookarounds Stand their Ground"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#uses"},"Various Uses for Lookarounds"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#zero_width"},"Zero-Width Matches"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#position"},"Positioning the Lookaround Before or After the Characters to be Matched"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#back_to_the_future"},"Lookarounds that Look on Both Sides: Back to the Future"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#compound"},"Compound Lookahead and Compound Lookbehind"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#atomic"},"The Engine Doesn't Backtrack into Lookarounds (They're Atomic)"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#width"},"Fixed-Width, Constrained-Width and Infinite-Width Lookbehind"),(0,o.kt)("br",{parentName:"p"}),"\n","\u273d\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#anchor"},"Lookarounds (Usually) Want to be Anchored"),"  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#password"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"lookahead-example-simple-password-validation"},"Lookahead Example: Simple Password Validation"),(0,o.kt)("p",null,"Let's get our feet wet right away with an expression that validates a password. The technique shown here will be useful for all kinds of other data you might want to validate (such as email addresses or phone numbers).",(0,o.kt)("br",{parentName:"p"}),"\n","Our password must meet four conditions:  "),(0,o.kt)("p",null,"1","."," The password must have between six and ten word characters\xa0","\\","w",(0,o.kt)("br",{parentName:"p"}),"\n","2","."," It must include at least one lowercase character\xa0","[","a-z","]",(0,o.kt)("br",{parentName:"p"}),"\n","3","."," It must include at least\xa0",(0,o.kt)("strong",{parentName:"p"},"three"),"\xa0uppercase characters\xa0","[","A-Z","]",(0,o.kt)("br",{parentName:"p"}),"\n","4","."," It must include at least one digit\xa0","\\","d  "),(0,o.kt)("p",null,"We'll assume we're working in a regex flavor where\xa0","\\","d\xa0only matches ASCII digits 0 through 9, unlike .NET and Python where that token can match any Unicode digit.  "),(0,o.kt)("p",null,"With lookarounds, your feet stay planted on the string. You're just looking, not moving!"),(0,o.kt)("p",null,"Our initial strategy (which we'll later tweak) will be to stand at the beginning of the string and\xa0",(0,o.kt)("strong",{parentName:"p"},"look ahead"),"\xa0four times\u2014once for each condition. We'll look to check we have the right number of characters, then we'll look for a lowercase letter, and so on. If all the lookaheads are successful, we'll know the string is a valid password\u2026 And we'll simply gobble it all up with a plain\xa0.","*","  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Let's start with condition 1"),(0,o.kt)("br",{parentName:"p"}),"\n","A string that is made of six-to-ten word characters can be written like this:\xa0","\\","A","\\","w{6,10}","\\","z",(0,o.kt)("br",{parentName:"p"}),"\n","The\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-anchors.html#A"},"\\","A\xa0anchor"),"\xa0asserts that the current position is the beginning of the string. After matching the six to ten word characters, the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-anchors.html#z"},"\\","z\xa0anchor"),"\xa0asserts that the current position is the end of the string.  "),(0,o.kt)("p",null,"Within a lookahead, this pattern becomes\xa0(?=","\\","A","\\","w{6,10}","\\","z). This lookahead asserts: at the current position in the string, what follows is the beginning of the string, six to ten word characters, and the very end of the string.  "),(0,o.kt)("p",null,"We want to make this assertion at the very beginning of the string. Therefore, to continue building our pattern, we want to anchor the lookahead with an\xa0","\\","A. There is no need to duplicate the\xa0","\\","A, so we can take it out of the lookahead. Our pattern becomes:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=\\w{6,10}\\z)"),(0,o.kt)("br",{parentName:"p"}),"\n","So far, we have an expression that validates that a string is entirely composed of six to ten word characters. Note that we haven't matched any of these characters yet: we have only looked ahead. The current position after the lookahead is still the beginning of the string. To check the other conditions, we just add lookaheads.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Condition 2"),(0,o.kt)("br",{parentName:"p"}),"\n","For our second condition, we need to check that the password contains one lowercase letter. To find one lowercase letter, the simplest idea is to use\xa0.","*","[","a-z","]",". That works, but the dot-star first shoots down to the end of the string, so we will always need to backtrack. Just for the sport, can we think of something more efficient? You might think of making the star quantifier reluctant by adding a\xa0?, giving us\xa0.","*","?","[","a-z","]",", but that too requires backtracking as a\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-quantifiers.html#lazy_expensive"},"lazy quantifier requires backtracking at each step"),".  "),(0,o.kt)("p",null,"For this type of situation, I recommend you use something like\xa0","[","^a-z","]","*","[","a-z","]","\xa0(or even better, depending on your engine, the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-disambiguation.html#atomic"},"atomic"),"\xa0(?",">","[","^a-z","]","*",")","[","a-z","]","\xa0or\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-quantifiers.html#possessive"},"possessive"),"\xa0version\xa0","[","^a-z","]","*","+","[","a-z","]","\u2014but we'll discuss that in the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#atomictweak"},"footnotes"),"). The negated character class\xa0","[","^a-z","]","\xa0is the\xa0",(0,o.kt)("em",{parentName:"p"},"counterclass"),"\xa0of the lowercase letter\xa0","[","a-z","]","\xa0we are looking for: it matches one character that is not a lowercase letter, and the\xa0","*","\xa0quantifier makes us match zero or more such characters. The pattern\xa0","[","^a-z","]","*","[","a-z","]","\xa0is a good example of the principle of\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-style.html#contrast"},"contrast"),"\xa0recommended by the regex style guide.  "),(0,o.kt)("p",null,"Let's use this pattern inside a lookahead:\xa0(?=","[","^a-z","]","*","[","a-z","]",")",(0,o.kt)("br",{parentName:"p"}),"\n","The lookahead asserts: at this position in the string (i.e., the beginning of the string), we can match zero or more characters that are not lowercase letters, then we can match one lowercase letter:\xa0","[","a-z","]",(0,o.kt)("br",{parentName:"p"}),"\n","Our pattern becomes:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=\\w{6,10}\\z)(?=[^a-z]*[a-z])"),(0,o.kt)("br",{parentName:"p"}),"\n","At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead twice. We still haven't matched any characters. Note that on a logical level it doesn't matter which condition we check first. If we swapped the order of the lookaheads, the result would be the same.  "),(0,o.kt)("p",null,"We have two more conditions to satisfy: two more lookaheads.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Condition 3"),(0,o.kt)("br",{parentName:"p"}),"\n","For our third condition, we need to check that the password contains at least three uppercase letters. The logic is similar to condition 2: we look for an optional number of non-uppercase letters, then one uppercase letter\u2026 But we need to repeat that three times, for which we'll use the quantifier\xa0{3}.",(0,o.kt)("br",{parentName:"p"}),"\n","We'll use this lookahead:\xa0(?=(?:","[","^A-Z","]","*","[","A-Z","]","){3})  "),(0,o.kt)("p",null,"The lookahead asserts: at this position in the string (i.e., the beginning of the string), we can do the following three times: match zero or more characters that are not uppercase letters (the job of the negated character class\xa0","[","^A-Z","]","\xa0with the quantifier\xa0","*","), then match one uppercase letter:\xa0","[","A-Z","]",(0,o.kt)("br",{parentName:"p"}),"\n","Our pattern becomes:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=\\w{6,10}\\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})"),(0,o.kt)("br",{parentName:"p"}),"\n","At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead three times. We still haven't matched any characters.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Condition 4"),(0,o.kt)("br",{parentName:"p"}),"\n","To check that the string contains at least one digit, we use this lookahead:\xa0(?=","\\","D","*","\\","d). Opposing\xa0","\\","d\xa0to its counterclass\xa0","\\","D\xa0makes good use of the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-style.html#contrast"},"regex principle of contrast"),".  "),(0,o.kt)("p",null,'The lookahead asserts: at this position in the string (i.e., the beginning of the string), we can match zero or more characters that are not digits (the job of the "not-a-digit" character class\xa0',"\\","D\xa0and the\xa0","*","\xa0quantifier), then we can match one digit:\xa0","\\","d",(0,o.kt)("br",{parentName:"p"}),"\n","Our pattern becomes:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=\\w{6,10}\\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\\D*\\d)"),(0,o.kt)("br",{parentName:"p"}),"\n","At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead four times to check our four conditions. We still haven't matched any characters, but we have validated our string: we know that it is a valid password.  "),(0,o.kt)("p",null,"If all we wanted was to validate the password, we could stop right there. But if for any reason we also need to match and return the entire string\u2014perhaps because we ran the regex on the output of a function and the password's characters haven't yet been assigned to a variable\u2014we can easily do so now.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Matching the Validated String"),(0,o.kt)("br",{parentName:"p"}),"\n","After checking that the string conforms to all four conditions, we are still standing at the beginning of the string. The five assertions we have made (the anchor\xa0","\\","A\xa0and the four lookaheads) have not changed our position. At this stage, we can use a simple\xa0.","*","\xa0to gobble up the string: we know that whatever characters are matched by the dot-star, the string is a valid password. The pattern becomes:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=\\w{6,10}\\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\\D*\\d).*"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#n-1conds"},"(direct link)"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Fine-Tuning: Removing One Condition"),"  "),(0,o.kt)("p",null,"For n conditions,",(0,o.kt)("br",{parentName:"p"}),"\n","use n-1 lookaheads"),(0,o.kt)("p",null,"If you examine our lookaheads, you may notice that the pattern\xa0","\\","w{6,10}","\\","z\xa0inside the first one examines all the characters in the string. Therefore, we could have used this pattern to match the whole string instead of the dot-star\xa0.","*","  "),(0,o.kt)("p",null,"This allows us to remove one lookahead and to simplify the pattern to this:  "),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\\D*\\d)\\w{6,10}\\z"),(0,o.kt)("br",{parentName:"p"}),"\n","The pattern\xa0","\\","w{6,10}","\\","z\xa0now serves the double purpose of matching the whole string and of ensuring that the string is entirely composed of six to ten word characters.  "),(0,o.kt)("p",null,"Generalizing this result, if you must check for n conditions, your pattern only needs to include n-1 lookaheads at the most. Often, you are even able to combine several conditions into a single lookahead.  "),(0,o.kt)("p",null,"You may object that we were able to use\xa0","\\","w{6,10}","\\","z\xa0because it happened to match the whole string. Indeed that was the case. But we could also have converted any of the other three lookaheads to match the entire string. For instance, taking the lookahead\xa0(?=","\\","D","*","\\","d)\xa0which checks for the presence of one digit, we can add a simple\xa0.","*","\\","z\xa0to get us to the end of the string.  "),(0,o.kt)("p",null,"The pattern would have become:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=\\w{6,10}\\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})\\D*\\d.*\\z"),(0,o.kt)("br",{parentName:"p"}),"\n","By the way, you may wonder why I bother using the\xa0","\\","z\xa0after the\xa0.","*",": shouldn't it get me to the end of the string? In general, not so: unless we're in\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-modifiers.html#dotall"},"DOTALL mode"),", the dot doesn't match line breaks. Therefore, the\xa0.","*","\xa0only gets you to the end of the first line. After this, the string may have line breaks and many more line. A\xa0","\\","z\xa0anchor ensures that after the\xa0.","*","\xa0we have reached not only the end of the line, but also the end of the string.  "),(0,o.kt)("p",null,"In this particular pattern, the first lookaround\xa0(?=","\\","w{6,10}","\\","z)\xa0already ensures that there cannot be any line breaks in the string, so the final\xa0","\\","z\xa0is not strictly necessary.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#order"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"the-order-of-lookaheads-doesnt-matter-almost"},"The Order of Lookaheads Doesn't Matter\u2026 Almost"),(0,o.kt)("p",null,"In our password validation pattern, since the three lookaheads don't change our position in the string, we can rearrange them in any order without affecting the overall logic.  "),(0,o.kt)("p",null,"While the order of lookaheads doesn't matter on a logical level, keep in mind that it may matter for matching speed. If one lookahead is more likely to fail than the other two, it makes little sense to place it in third position and expend a lot of energy checking the first two conditions. Make it first, so that if we're going to fail, we fail early\u2014an application of the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-style.html#design_to_fail"},(0,o.kt)("em",{parentName:"a"},"design to fail"),"\xa0principle"),"\xa0from the regex style guide.  "),(0,o.kt)("p",null,"In fact, this is what we do by placing the anchor\xa0","\\","A\xa0in first position. Since it is an assertion that doesn't consume characters, it too could swap positions with any of the lookaheads. We'll see why this is a bad idea, but first\u2026  "),(0,o.kt)("p",null,"In passing, consider that\xa0","\\","A\xa0can be written with lookarounds: in\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-modifiers.html#dotall"},"DOTALL mode"),", where the dot matches any character including line breaks, the negative lookbehind\xa0(?<!.)\xa0asserts that what precedes the current position is not\xa0",(0,o.kt)("em",{parentName:"p"},"any character"),"\u2014therefore the position must be the beginning of the string. Without DOTALL mode, the negative lookbehind\xa0(?<!","[","\\","D","\\","d","]",")\xa0asserts the same, since\xa0","[","\\","D","\\","d","]","\xa0matches one character that is either a digit or a non-digit\u2014in other words, any character.  "),(0,o.kt)("p",null,"Now imagine we set\xa0","\\","A\xa0in fourth position, after the three lookaheads. The resulting match would be the same, but it could take a lot more time. For instance, suppose the third lookahead (whose job it is to assert that the string contains at least one digit) fails. After failing to find a match at the first position in the string, the engine advances to the second position and tries the lookaheads again, one after the other. Once more, the third lookahead is bound to fail to find a digit. After each failure, the engine will start a new match attempt starting at the next position in the string. Even when the two first lookaheads succeed (and they may fail, as the uppercase or lowercase letter they check for may have been the lone one in the string, and at a position already passed), the third lookahead will always fail to find a digit. Therefore the anchor\xa0","\\","A\xa0is never even attempted: the pattern fails before the engine reaches that token.  "),(0,o.kt)("p",null,"In contrast, when\xa0","\\","A\xa0is first, it can only match at the first position in the string. The third lookahead still fails, but when the engine tries to match at further positions, the\xa0","\\","A\xa0immediately fails, so the engine doesn't need to waste any more time with the lookaheads.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#stand_their_ground"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"lookarounds-stand-their-ground"},"Lookarounds Stand their Ground"),(0,o.kt)("p",null,"If I seem to be flogging a dead horse here, it's only because this point is the most common source of confusion with lookarounds. As the password validation example made clear, lookarounds stand their ground. They look immediately to the left or right of the engine's current position on the string\u2014but do not alter that position.  "),(0,o.kt)("p",null,"Therefore, do not expect the pattern\xa0A(?=5)\xa0to match the\xa0",(0,o.kt)("em",{parentName:"p"},"A"),"\xa0in the string\xa0",(0,o.kt)("em",{parentName:"p"},"AB25"),'. Many beginners assume that the lookahead says that "there is a\xa0',(0,o.kt)("em",{parentName:"p"},"5"),'\xa0somewhere to the right", but that is not so. After the engine matches the\xa0',(0,o.kt)("em",{parentName:"p"},"A"),", the lookahead\xa0(?=5)\xa0asserts that at the current position in the string, what immediately follows is a\xa0",(0,o.kt)("em",{parentName:"p"},"5"),". If you want to check if there is a\xa0",(0,o.kt)("em",{parentName:"p"},"5"),"\xa0somewhere (anywhere) to the right, you can use\xa0(?=","[","^5","]","*","5).  "),(0,o.kt)("p",null,"Moreover, don't expect the pattern\xa0A(?=5)(?=","[","A-Z","]",")\xa0to match the\xa0",(0,o.kt)("em",{parentName:"p"},"A"),"\xa0in the string\xa0",(0,o.kt)("em",{parentName:"p"},"A5B"),". Many beginners assume that the second lookahead looks to the right of the first lookahead. It is not so. At the end of the first lookahead, the engine is still planted at the very same spot in the string, after the\xa0",(0,o.kt)("em",{parentName:"p"},"A"),". When the lookahead\xa0(?=","[","A-Z","]",")\xa0tries to assert that what immediately follows the current position is an uppercase letter, it fails because the next character is still the\xa0",(0,o.kt)("em",{parentName:"p"},"5"),". If you want to check that the 5 is followed by an uppercase letter, just state it in the first lookahead:\xa0(?=5","[","A-Z","]",")  "),(0,o.kt)("p",null,"So\xa0",(0,o.kt)("em",{parentName:"p"},"lookahead"),"\xa0and\xa0",(0,o.kt)("em",{parentName:"p"},"lookbehind"),'\xa0don\'t mean "look way ahead into the distance". They mean "look at the text immediately to the left or to the right". If you want to inspect a piece of string further down, you will need to insert "binoculars" inside the lookahead to get you to the part of the string you want to inspect\u2014for instance a\xa0.',"*",", or, ideally, more specific tokens.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#uses"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"various-uses-for-lookarounds"},"Various Uses for Lookarounds"),(0,o.kt)("p",null,"Before we dive into interesting but sometimes terse details, let's get excited about lookarounds by surveying some of their terrific uses.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Validation"),(0,o.kt)("br",{parentName:"p"}),"\n","The\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#password"},"password validation"),"\xa0section showed how the combination of several lookaheads can impose a number of conditions on the string to be matched, allowing us to validate it with a single pattern.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Restricting a Character Range (Subtraction, Intersection)"),(0,o.kt)("br",{parentName:"p"}),"\n","Suppose you want to match one word character\xa0","\\","w\xa0as long as it is not the letter\xa0",(0,o.kt)("em",{parentName:"p"},"Q"),". There are several ways to do it without lookarounds:",(0,o.kt)("br",{parentName:"p"}),"\n","\u273d In engines that support\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-class-operations.html#subtraction"},"character class subtraction"),", you can use\xa0","[","\\","w-","[","Q","]","]","\xa0(.NET),\xa0","[","\\","w&&","[","^Q","]","]","\xa0(Java and Ruby 1.9+) or\xa0","[","\\","w--Q","]","\xa0(Python with the alternate\xa0",(0,o.kt)("em",{parentName:"p"},"regex"),"\xa0module)",(0,o.kt)("br",{parentName:"p"}),"\n","\u273d You can build a character class such as\xa0","[","_","0-9a-zA-PR-Z","]",(0,o.kt)("br",{parentName:"p"}),"\n","\u273d You can use\xa0","[","^","\\","WQ","]","\u2014an example of an\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-interesting-character-classes.html#obnoxious"},"obnoxious double-negative character range"),".  "),(0,o.kt)("p",null,"If your engine doesn't support character class subtraction, the simplest may be to use the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-class-operations.html#subtraction_workaround"},"workaround"),"\xa0shown on the page about class operations. This uses a lookahead to restrict the character class\xa0","\\","w:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?!Q)\\w"),"After the negative lookahead asserts that what follows the current position is not a\xa0",(0,o.kt)("em",{parentName:"p"},"Q"),", the\xa0","\\","w\xa0matches a word character.  "),(0,o.kt)("p",null,"Not only is this solution easy to read, it is also easy to maintain if we ever decide to exclude the letter\xa0",(0,o.kt)("em",{parentName:"p"},"K"),"\xa0instead of\xa0",(0,o.kt)("em",{parentName:"p"},"Q"),", or to exclude both:\xa0(?!","[","QK","]",")","\\","w  "),(0,o.kt)("p",null,"Note that we can also perform the same exclusion task with a negative lookbehind:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\w(?<!Q)"),"After the\xa0","\\","w\xa0matches a word character, the negative lookbehind asserts that what precedes the current position is not a\xa0",(0,o.kt)("em",{parentName:"p"},"Q"),".  "),(0,o.kt)("p",null,"Using the same idea, if we wanted to match one character in the Arabic script as long as it is not a number, we could use this pattern:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?!\\p{N})\\p{Arabic}"),"This would work in Perl, PCRE (C, PHP, R\u2026) and Ruby 2+. In .NET and Java, you would use\xa0(?!","\\","p{N})","\\","p{IsArabic}  "),(0,o.kt)("p",null,"Likewise, we can use this technique to perform a DIY\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-class-operations.html#intersection"},"character class intersection"),". For instance, to match one character in the Arabic script as long as it is a number, we transform the negative lookahead above to a positive lookahead. In the Perl / PCRE / Ruby version, this gives us:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?=\\p{N})\\p{Arabic}"),(0,o.kt)("br",{parentName:"p"}),"\n","This is basically the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#password"},"password validation technique"),"\xa0with two conditions applied to a single character.  "),(0,o.kt)("p",null,"Needless to say, you can interchange the content of the lookahead with the token to be matched:",(0,o.kt)("inlineCode",{parentName:"p"},"(?=\\p{Arabic})\\p{N}"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Tempering the scope of a token"),(0,o.kt)("br",{parentName:"p"}),"\n","This use is similar to the last. Instead of removing characters from a class, it restricts the scope within which a token is allowed to match.  "),(0,o.kt)("p",null,"For instance, suppose we want to match any character as long as it is not followed by\xa0",(0,o.kt)("em",{parentName:"p"},"{END}"),". Using a negative lookahead, we can use:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?:(?!{END}).)*"),"Each\xa0.\xa0token is tempered by\xa0(?!{END}), which specifies that the dot cannot be the beginning of\xa0",(0,o.kt)("em",{parentName:"p"},"{END}"),". This technique is called\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-quantifiers.html#tempered_greed"},(0,o.kt)("em",{parentName:"a"},"tempered greedy token")),"\xa0on the\xa0",(0,o.kt)("em",{parentName:"p"},"Quantifiers page"),".  "),(0,o.kt)("p",null,"Another technique is:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?:[^{]++|{(?!END}))*+"),"On the left side of the alternation,\xa0","[","^{","]","++\xa0matches characters that are not an opening brace. On the right side,\xa0{(?!END})\xa0matches an opening brace that is not followed by\xa0",(0,o.kt)("em",{parentName:"p"},"END}"),". This technique appears in the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-quantifiers.html#explicit_greed"},(0,o.kt)("em",{parentName:"a"},"Explicit Greedy Alternation")),"\xa0section of the\xa0",(0,o.kt)("em",{parentName:"p"},"Quantifiers page"),".  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Delimiter"),(0,o.kt)("br",{parentName:"p"}),"\n","Do you have a string where you want to start matching all characters once the first instance of\xa0",(0,o.kt)("em",{parentName:"p"},"#START#"),"\xa0is passed? No problem, just use a lookbehind to make a delimiter:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=#START#).*"),"After the lookbehind asserts that what immediately precedes the current position is\xa0",(0,o.kt)("em",{parentName:"p"},"#START#"),", the dot-star\xa0.","*","\xa0matches all the characters to the right.  "),(0,o.kt)("p",null,"Or would you like to match all characters in a string up to, but not including the characters\xa0",(0,o.kt)("em",{parentName:"p"},"#END#"),"? Make a delimiter using a lookahead:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},".*?(?=#END#)"),(0,o.kt)("br",{parentName:"p"}),"\n","You can, of course, combine the two:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=#START#).*?(?=#END#)"),(0,o.kt)("br",{parentName:"p"}),"\n","See the page on boundaries for advice on building fancy\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-boundaries.html#diy"},"DIY delimiters"),".  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#camelinsert"},"(direct link)"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Inserting Text at a Position"),(0,o.kt)("br",{parentName:"p"}),"\n","Someone gave you a file full of film titles in CamelCase, such as\xa0",(0,o.kt)("em",{parentName:"p"},"HaroldAndKumarGoToWhiteCastle"),". To make it easier to read, you want to insert a space at each position between a lowercase letter and an uppercase letter. This regex matches these exact positions:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=[a-z])(?=[A-Z])"),(0,o.kt)("br",{parentName:"p"}),"\n","In your text editor's regex replacement function, all you have to do is replace the matches space characters, and spaces be inserted in the right spot.  "),(0,o.kt)("p",null,'This regex is what\'s known as a "zero-width match" because it matches a position without matching any actual characters. How does it work? The lookbehind asserts that what immediately precedes the current position is a lowercase letter. And the lookahead asserts that what immediately follows the current position is an uppercase letter.  '),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#camelsplit"},"(direct link)"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Splitting a String at a Position"),(0,o.kt)("br",{parentName:"p"}),"\n","We can use the exact same regex from the previous example to split the string\xa0",(0,o.kt)("em",{parentName:"p"},"AppleOrangeBananaStrawberryPeach"),"\xa0into a list of fruits. Once again, the regex",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=[a-z])(?=[A-Z])"),"matches the positions between a lowercase letter and an uppercase letter.  "),(0,o.kt)("p",null,"In most languages, when you feed this regex to the function that uses a regex pattern to split strings, it returns an array of words.  "),(0,o.kt)("p",null,"Note that Python's\xa0",(0,o.kt)("em",{parentName:"p"},"re"),"\xa0module does not split on zero-width matches\u2014but the far superior\xa0",(0,o.kt)("em",{parentName:"p"},"regex"),"\xa0module does.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#overlapping"},"(direct link)"),(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Finding Overlapping Matches"),(0,o.kt)("br",{parentName:"p"}),"\n","Sometimes, you need several matches within the same word. For instance, suppose that from a string such as\xa0",(0,o.kt)("em",{parentName:"p"},"ABCD"),"\xa0you want to extract\xa0",(0,o.kt)("em",{parentName:"p"},"ABCD"),",\xa0",(0,o.kt)("em",{parentName:"p"},"BCD"),",\xa0",(0,o.kt)("em",{parentName:"p"},"CD"),"\xa0and\xa0",(0,o.kt)("em",{parentName:"p"},"D"),". You can do it with this single regex:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?=(\\w+))"),"When you allow the engine to find all matches, all the substrings will be captured to Group 1  "),(0,o.kt)("p",null,"How does this work?  "),(0,o.kt)("p",null,"At the first position in the string (before the\xa0",(0,o.kt)("em",{parentName:"p"},"A"),"), the engine starts the first match attempt. The lookahead asserts that what immediately follows the current position is one or more word characters, and captures these characters to Group 1. The lookahead succeeds, and so does the match attempt. Since the pattern didn't match any actual characters (the lookahead only looks), the engine returns a zero-width match (the empty string). It also returns what was captured by Group 1:\xa0",(0,o.kt)("em",{parentName:"p"},"ABCD"),"  "),(0,o.kt)("p",null,"The engine then moves to the next position in the string and starts the next match attempt. Again, the lookahead asserts that what immediately follows that position is word characters, and captures these characters to Group 1. The match succeeds, and Group 1 contains\xa0",(0,o.kt)("em",{parentName:"p"},"BCD"),".  "),(0,o.kt)("p",null,"The engine moves to the next position in the string, and the process repeats itself for\xa0",(0,o.kt)("em",{parentName:"p"},"CD"),"\xa0then\xa0",(0,o.kt)("em",{parentName:"p"},"D"),".  "),(0,o.kt)("p",null,"In .NET, which has infinite lookbehind, you can find overlapping matches from the other side of the string. For instance, on the same string\xa0",(0,o.kt)("em",{parentName:"p"},"ABCD"),", consider this pattern:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=(\\w+))"),(0,o.kt)("br",{parentName:"p"}),"\n","It will capture\xa0",(0,o.kt)("em",{parentName:"p"},"A"),",\xa0",(0,o.kt)("em",{parentName:"p"},"AB"),",\xa0",(0,o.kt)("em",{parentName:"p"},"ABC"),"\xa0and\xa0",(0,o.kt)("em",{parentName:"p"},"ABCD"),". To achieve the same in an engine that doesn't support infinite lookbehind, you would have to reverse the string, use the lookahead version\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"(?=(\\w+))"),"\xa0then reverse the captures.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#zero_width"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"zero-width-matches"},"Zero-Width Matches"),(0,o.kt)("p",null,"As we've seen, a lookaround looks left or right but it doesn't add any characters to the match to be returned by the regex engine. Likewise, an anchor such as\xa0^\xa0and a boundary such as\xa0","\\","b\xa0can match at a given position in the string, but they do not add any characters to the match.  "),(0,o.kt)("p",null,"Usually, lookaheads, lookbehinds, anchors and boundaries appear in patterns that contain tokens that do match characters, allowing the engine to return a matched string. For instance, in\xa0(?<\\=start","_",")","\\","d+, the engine matches and returns some digits, but not the prefix\xa0_start","_","_  "),(0,o.kt)("p",null,"However, if a pattern only contains lookarounds, anchors and boundaries, the engine may be able to match the pattern without matching any characters. The resulting match is called a\xa0",(0,o.kt)("em",{parentName:"p"},"zero-width match"),"\xa0because it contains no characters.  "),(0,o.kt)("p",null,"This can be a useful technique, and we have already seen some applications of zero-width matches in the section on\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#uses"},"uses for lookarounds"),". To bring them together under one heading, here are some of their main uses.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Validation"),(0,o.kt)("br",{parentName:"p"}),"\n","If you string several lookarounds in a row, you can validate that a string conforms to a set of rules, as in the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#password"},"password validation technique"),".  "),(0,o.kt)("p",null,"We saw that when you have n conditions, if you also want to match the string, you usually need n-1 lookarounds at the most as\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#n-1conds"},"one condition can be removed"),"\xa0and used in the matching section of the pattern. But if all you want to do is validate, all the conditions can stay inside lookarounds, giving you a zero-width match.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Inserting"),(0,o.kt)("br",{parentName:"p"}),"\n","You can use a zero-width match regex to match a position in a string and insert text at that position. For instance, by matching\xa0(?m)^\xa0(the beginning of a line in multiline mode) and replacing the match with\xa0// , you can add a prefix to every line of a file.  "),(0,o.kt)("p",null,"Likewise, we saw how the zero-width pattern\xa0(?<\\=","[","a-z","]",")(?=","[","A-Z","]",")\xa0allows you to\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#camelinsert"},"insert characters in a CamelCase word"),".  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Splitting"),(0,o.kt)("br",{parentName:"p"}),"\n","We saw how the same zero-width pattern\xa0(?<\\=","[","a-z","]",")(?=","[","A-Z","]",")\xa0allows you to\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#camelsplit"},"split a CamelCase word"),"\xa0into its components.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Overlapping Matches"),(0,o.kt)("br",{parentName:"p"}),"\n","We saw how an unanchored lookaround that contains capture groups\u2014such as\xa0(?=(","\\","w+))\u2014allows you to\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#overlapping"},"match overlapping string segments"),".  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#position"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"positioning-the-lookaround"},"Positioning the Lookaround"),(0,o.kt)("p",null,"Often, you have two options for positioning a lookaround: before the text to be matched, or after. Usually, one of the options is more efficient because it requires less work of the engine.  "),(0,o.kt)("p",null,"To illustrate this, here are examples for each kind of lookaround. I borrowed them from the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-disambiguation.html#lookarounds"},"lookarounds section"),"\xa0of the main syntax page, where they are discussed in greater detail.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Lookahead"),(0,o.kt)("br",{parentName:"p"}),"\n","\\","d+(?= dollars)\xa0and\xa0(?=","\\","d+ dollars)","\\","d+\xa0both match\xa0",(0,o.kt)("em",{parentName:"p"},"100"),"\xa0in\xa0100 dollars, but the first is more efficient because the engine needs to match\xa0","\\","d+\xa0only once.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Negative Lookahead"),(0,o.kt)("br",{parentName:"p"}),"\n","\\","d+(?! dollars)\xa0and\xa0(?!","\\","d+ dollars)","\\","d+\xa0both match\xa0",(0,o.kt)("em",{parentName:"p"},"100"),"\xa0in\xa0100 pesos, but the first is more efficient because the engine needs to match\xa0","\\","d+\xa0only once.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Lookbehind"),(0,o.kt)("br",{parentName:"p"}),"\n","(?<\\=USD)","\\","d{3}\xa0and\xa0","\\","d{3}(?<\\=USD","\\","d{3})\xa0both match\xa0",(0,o.kt)("em",{parentName:"p"},"100"),"\xa0in\xa0USD100, but the first is more efficient because the engine needs to match\xa0","\\","d{3}\xa0only once.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Negative Lookbehind"),(0,o.kt)("br",{parentName:"p"}),"\n","(?<!USD)","\\","d{3}\xa0and\xa0","\\","d{3}(?<!USD","\\","d{3})\xa0both match\xa0",(0,o.kt)("em",{parentName:"p"},"100"),"\xa0in\xa0JPY100, but the first is more efficient because the engine needs to match\xa0","\\","d{3}\xa0only once.  "),(0,o.kt)("p",null,"What may not be so clear is that each of these lookarounds can be used in two main ways: before the expression to be matched, or after it. These two ways have a slightly different feel. Please don't obsess over the differences; rather, just cruise through these simple examples to become familiar with the types of effects you can achieve.  "),(0,o.kt)("p",null,"When you compare each pair, the two methods have a different\xa0",(0,o.kt)("em",{parentName:"p"},"feel"),'. The point of the examples is not to make you memorize "the right position", but to expose you to those two basic feels. Once you\'re familiar with them, you will naturally think of rewriting a lookaround that feels too heavy. With a bit of practice, the efficient way of positioning your lookarounds will probably come to you naturally.  '),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#back_to_the_future"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"lookarounds-that-look-on-both-sides-back-to-the-future"},"Lookarounds that Look on Both Sides: Back to the Future"),(0,o.kt)("p",null,"Suppose you want to match a two-digit number surrounded by underscores as in\xa0","_","12","_","\xa0but not the underscores.  "),(0,o.kt)("p",null,"We have already seen three ways to do this:",(0,o.kt)("br",{parentName:"p"}),"\n","\u273d You can match everything and capture the digits to Group 1:\xa0","_","(","\\","d{2})","_",(0,o.kt)("br",{parentName:"p"}),"\n","\u273d You can use a lookbehind and a lookahead:\xa0(?<\\=","_",")","\\","d{2}(?=","_",")",(0,o.kt)("br",{parentName:"p"}),"\n","\u273d You can use\xa0","\\","K\xa0to drop the first underscore from the match:\xa0","_","\\","K","\\","d{2}(?=","_",")  "),(0,o.kt)("p",null,"There is a fourth technique I'd like to introduce you to. I call it the \"back to the future lookbehind.\" There shouldn't be any reason to use it on its own, but sometimes within an intricate pattern it may just what you need, so it's nice to be familiar with it and add it to your repertoire.  "),(0,o.kt)("p",null,"We can position our back-to-the-future lookbehind before or after the digits. Let's start with the\xa0",(0,o.kt)("em",{parentName:"p"},"before"),"\xa0version:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=_(?=\\d{2}_))\\d+"),(0,o.kt)("br",{parentName:"p"}),"\n","Wowzy, what does this do? The lookbehind asserts that what immediately precedes the current position in the string is an underscore, then a position where the lookahead\xa0(?=","\\","d{2}","_",")\xa0can assert that what immediately follows is two digits and an underscore.  "),(0,o.kt)("p",null,"This is interesting for several reasons. First, we have a lookahead within a lookbehind, and even though we were supposed to look backwards, this lookahead jumps over the current position by matching the two digits and the trailing underscore. That's acrobatic.  "),(0,o.kt)("p",null,"Second, note that even though it looks complex, this is a fixed-width lookbehind (the width is one character, the underscore), so it should work in all flavors of lookbehind. (However, it does not work in Ruby as Ruby does not allow lookaheads and negative lookbehinds inside lookbehind.)  "),(0,o.kt)("p",null,'Another interesting feature is how the notion of "current position in the string" is not the same for the lookbehind and for the lookahead. You\'ll remember that\xa0',(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#stand_their_ground"},"lookarounds stand their ground"),", so that after checking the assertion made by a lookaround, the engine hasn't moved in the string. Are we breaking that rule?  "),(0,o.kt)("p",null,"We're not. In the string\xa0",(0,o.kt)("em",{parentName:"p"},"10 ","_","16","_"," 20"),", let's say the engine has reached the position between the underscore and the\xa0",(0,o.kt)("em",{parentName:"p"},"1"),"\xa0in\xa0",(0,o.kt)("em",{parentName:"p"},"16"),". The lookbehind makes an assertion about what can be matched at that position. When the engine exits the lookbehind, it is still standing in that same spot, and the token\xa0","\\","d{2}\xa0can proceed to match the characters\xa0",(0,o.kt)("em",{parentName:"p"},"16"),".  "),(0,o.kt)("p",null,"But within the lookbehind itself, we enter a different little world. You can imagine that outside that world the engine is red, and inside the little world of the lookbehind, there is another little engine which is yellow. That yellow engine keeps track of its own position in the string. In most engines (.NET proceeds differently), the yellow engine is initially dropped at a position in the string that is found by taking the red engine's position and subtracting the width of the lookbehind, which is 1. The yellow engine therefore starts its work before the leading underscore. Within the lookbehind's little world, after matching the underscore token, the yellow engine's position in the string is between the underscore and the\xa0",(0,o.kt)("em",{parentName:"p"},"1"),". It is that position that the lookahead refers to when it asserts that at the current position in the string (according to the little world of the lookbehind and its yellow engine), what immediately follows is two digits and an underscore.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"After the digits"),(0,o.kt)("br",{parentName:"p"}),"\n",'Here is a second version where the "back-to-the-future lookbehind" comes after the digits:',(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\d+(?<=_\\d{2}(?=_))"),(0,o.kt)("br",{parentName:"p"}),"\n","The lookbehind states: what immediately precedes this position in the string is an underscore and two digits, then a position where the lookahead\xa0(?=","_",")\xa0can assert that what immediately follows the current position in the string (according to the yellow engine and the lookbehind's little world) is an underscore.  "),(0,o.kt)("p",null,"This too is a fixed-width lookbehind (the width is three character, i.e. the leading underscore and the two digits), so it should work in all flavors of lookbehind except Ruby.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#compound"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"compound-lookahead-and-compound-lookbehind"},"Compound Lookahead and Compound Lookbehind"),(0,o.kt)("p",null,"The\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#back_to_the_future"},"back-to-the-future lookbehind"),"\xa0introduced us to what I call\xa0",(0,o.kt)("em",{parentName:"p"},"compound lookarounds"),", i.e., lookarounds that contain other lookarounds. You could also call them\xa0",(0,o.kt)("em",{parentName:"p"},"nested lookarounds"),", but for me the idea of compounding captures something more about the feel of working with these constructs.  "),(0,o.kt)("p",null,"Let's look at some examples.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Token followed by one character, but not more"),(0,o.kt)("br",{parentName:"p"}),"\n","How can you match a number that is followed by one underscore, but not more?  "),(0,o.kt)("p",null,"You can use this:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\d+(?=_(?!_))"),"The lookahead asserts: what follows the current position in the string is one underscore, then a position where the negative lookahead\xa0(?!","_",")\xa0can assert that what follows is not an underscore. A less elegant variation would be\xa0","\\","d+(?=(?!","_","_",")","_",")  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Token preceded by one character, but not more"),(0,o.kt)("br",{parentName:"p"}),"\n","How can you match a number that is preceded by one underscore, but not more?  "),(0,o.kt)("p",null,"You can use this:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=(?<!_)_)\\d+"),"The lookbehind asserts: what precedes the current position in the string is a position where the negative lookbehind\xa0(?<!","_",")\xa0can assert that what immediately precedes is not an underscore, then an underscore. A variation would be\xa0(?<\\=","_","(?<!","_","_","))","\\","d+  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Multiple Compounding"),(0,o.kt)("br",{parentName:"p"}),"\n","Needless to say, it won't be long until you find occasions to add levels of compounding beyond the two we've just seen. But that quickly becomes obnoxious, and it becomes simpler to rearrange the regex. For instance, building on the previous pattern,",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=(?<!(?<!X)_)_)\\d+"),"matches a number that is precede by an underscore that is not preceded by an underscore unless that underscore is preceded by an\xa0",(0,o.kt)("em",{parentName:"p"},"X"),".  "),(0,o.kt)("p",null,"In .NET, PCRE, Java and Ruby, this could be simplified to\xa0(?<\\=(?<!","_",")","_","|X","_","_",")","\\","d+",(0,o.kt)("br",{parentName:"p"}),"\n","In Perl and Python, you could use\xa0(?:(?<\\=(?<!","_",")","_",")|(?<\\=X","_","_","))","\\","d+  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#atomic"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"the-engine-doesnt-backtrack-into-lookarounds"},"The Engine Doesn't Backtrack into Lookarounds\u2026"),(0,o.kt)("p",null,"\u2026because they're atomic"),(0,o.kt)("p",null,"Here's a fun regex task. You have a string like this:",(0,o.kt)("br",{parentName:"p"}),"\n","_","rabbit ","_","dog ","_","mouse DIC\ud83d\udc31dog:mouse",(0,o.kt)("br",{parentName:"p"}),"\n","The\xa0",(0,o.kt)("em",{parentName:"p"},"DIC"),"\xa0section at the end contains a list of allowed animals. Our job is to match all the\xa0",(0,o.kt)("em",{parentName:"p"},"_","tokens"),"\xa0named after an allowed animal. Therefore, we expect to match\xa0",(0,o.kt)("em",{parentName:"p"},"_","dog"),"\xa0and\xa0",(0,o.kt)("em",{parentName:"p"},"_","mouse"),". A lookaround helps us do this:  "),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_(\\w+)\\b(?=.*:\\1\\b)"),(0,o.kt)("br",{parentName:"p"}),"\n","After matching the underscore, we capture a word to Group 1. Then the lookahead\xa0(?=.","*",":","\\","1","\\","b)\xa0asserts what follows the current position in the string is zero or more characters, then a colon, then the word captured to Group 1. As hoped, this matches both\xa0",(0,o.kt)("em",{parentName:"p"},"_","dog"),"\xa0and\xa0",(0,o.kt)("em",{parentName:"p"},"_","mouse"),".  "),(0,o.kt)("p",null,'Now suppose we try a "reversed" approach:  '),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_(?=.*:(\\w+)\\b)\\1\\b"),(0,o.kt)("br",{parentName:"p"}),"\n","This only matches\xa0",(0,o.kt)("em",{parentName:"p"},"_","mouse"),". Why?  "),(0,o.kt)("p",null,"First let's try to understand what this regex hopes to accomplish. It may not be that obvious, but it illustrates an important feature of lookarounds.  "),(0,o.kt)("p",null,"After the engine matches the underscore, the lookahead\xa0(?=.","*",":(","\\","w+)","\\","b)\xa0asserts that what follows the current position in the string is any number of characters, then a colon, then a word (captured to Group 1). After passing that assertion, the back-reference\xa0","\\","1\xa0matches what was captured into Group 1.  "),(0,o.kt)("p",null,"Let's see how this works out. Remember that our string is",(0,o.kt)("br",{parentName:"p"}),"\n","_","rabbit ","_","dog ","_","mouse DIC\ud83d\udc31dog:mouse",(0,o.kt)("br",{parentName:"p"}),"\n","After the underscore that precedes\xa0",(0,o.kt)("em",{parentName:"p"},"rabbit"),", we expect the lookahead to fail because there is no\xa0",(0,o.kt)("em",{parentName:"p"},"rabbit"),"\xa0in the\xa0",(0,o.kt)("em",{parentName:"p"},"DIC"),"\xa0section\u2014and it does. The next time we match an underscore is before\xa0",(0,o.kt)("em",{parentName:"p"},"dog"),". At that stage, inside the lookahead\xa0(?=.","*",":(","\\","w+)","\\","b), the dot-star shoots down to the end of the string, then backtracks just far enough to allow the colon to match, after which the word\xa0",(0,o.kt)("em",{parentName:"p"},"mouse"),"\xa0is matched and captured to Group 1. The lookahead succeeds. The next token\xa0","\\","1\xa0tries to match\xa0",(0,o.kt)("em",{parentName:"p"},"mouse"),", but the next character in the string is the\xa0",(0,o.kt)("em",{parentName:"p"},"d"),"\xa0from\xa0",(0,o.kt)("em",{parentName:"p"},"dog"),", so the token fails. At this stage, having learned everything about backtracking, we might assume that the regex engine allows the dot-star to backtrack even more inside the lookahead, up to the previous colon, which would then allow\xa0(","\\","w+)\xa0to match and capture\xa0",(0,o.kt)("em",{parentName:"p"},"mouse"),". Then the back-reference\xa0","\\","1\xa0would match\xa0",(0,o.kt)("em",{parentName:"p"},"mouse"),", and the engine would return a successful match.  "),(0,o.kt)("p",null,"However, it does not work that way. Once the regex engine has left a lookaround, it will not backtrack into it if something fails somewhere down the pattern. On a logical level, that is because the official point of a lookaround is to return one of two values:\xa0true\xa0or\xa0false. Once a lookahead evaluates to\xa0true\xa0at a given position in the string, it is always true. From the engine's standpoint, there is nothing to backtrack. What would be the point\u2014since the only other available value is\xa0false, and that would fail the pattern?  "),(0,o.kt)("p",null,"The fact that the engine will not backtrack into a lookaround means that it is an\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-disambiguation.html#atomic"},"atomic block"),". This property of lookarounds will rarely matter, but if someday, in the middle of building an intricate pattern, a lookahead refuses to cooperate\u2026 This may be the reason.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#width"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"fixed-width-constrained-width-and-infinite-width-lookbehind"},"Fixed-Width, Constrained-Width and Infinite-Width Lookbehind"),(0,o.kt)("p",null,"In strings such as\xa0",(0,o.kt)("em",{parentName:"p"},"123456","_","ORANGE abc12","_","APPLE"),", suppose you are interested in matching uppercase words, provided they are preceded by a prefix composed of digits and an underscore character. Therefore, in this string, you want to match\xa0",(0,o.kt)("em",{parentName:"p"},"ORANGE"),"\xa0but not\xa0",(0,o.kt)("em",{parentName:"p"},"APPLE"),".  "),(0,o.kt)("p",null,"It's worth remembering that in most regex flavors (.NET is one of the few exceptions), the following pattern is invalid:  "),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"(?<=\\b\\d+_)[A-Z]+"),(0,o.kt)("br",{parentName:"p"}),"\n","That is because the width of the text matched by the token\xa0","\\","d+\xa0can be anything. Most engines require the width of the subexpression within a lookbehind to be known in advance, as in\xa0(?<\\=","\\","d{3})  "),(0,o.kt)("p",null,"Some engines allow the width of the subexpression within a lookbehind to take various pre-determined values found on the various sides of an alternation, as in\xa0(?<\\=0|128|","\\","d{6}). Yet others allow the width to vary within a pre-determined range, as in\xa0(?<\\=d{2,6})  "),(0,o.kt)("p",null,"For details of what kinds of widths various engines allow in a lookbehind, see the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-disambiguation.html#lookbehind_width"},"Lookbehind: Fixed-Width / Constrained Width / Infinite Width"),"\xa0section of the main syntax page. To honor the winners, I'll just repeat here that the only two programming-language flavors that support infinite-width lookbehind are .NET (C#, VB.NET, \u2026) and Matthew Barnett's\xa0",(0,o.kt)("a",{parentName:"p",href:"https://pypi.python.org/pypi/regex"},(0,o.kt)("em",{parentName:"a"},"regex"),"\xa0module"),"\xa0for Python. I've also implemented an\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/pcre-callouts.html#infinite_lb"},"infinite lookbehind demo for PCRE"),".  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Capture Group Inside Variable Lookbehind: Difference between Java and .NET"),(0,o.kt)("br",{parentName:"p"}),"\n","Both Java and .NET allow this pattern:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=(\\d{1,5}))Z"),(0,o.kt)("br",{parentName:"p"}),"\n",".NET allows it because it supports infinite-width lookbehind. Java allows it because it supports lookbehind whose width falls within a defined range. However, they operate differently. As a result, against the string\xa0",(0,o.kt)("em",{parentName:"p"},"123Z"),", this pattern will return different Group 1 captures in the two engines.  "),(0,o.kt)("p",null,"\u273d Java captures\xa0",(0,o.kt)("em",{parentName:"p"},"3"),"\xa0to Group 1. The engine sees that the width of the string to be matched inside the lookbehind must fall between one and five characters. Java tries all the possible fixed-width patterns in the range, from the shortest to the longest, until one succeeds. The shortest possible fixed-width pattern is\xa0(?<\\=(","\\","d{1})). The engine temporarily skips back one character in the string, tries to match\xa0","\\","d{1}\xa0and succeeds. The lookaround succeeds, and Group 1 contains\xa0",(0,o.kt)("em",{parentName:"p"},"3"),".  "),(0,o.kt)("p",null,"\u273d .NET captures\xa0",(0,o.kt)("em",{parentName:"p"},"123"),"\xa0to Group 1. The .NET engine has a far more efficient way of processing variable-width lookbehinds. Instead of trying multiple fixed-width patterns starting at points further and further back in the string, .NET reverses the string as well as the pattern inside the lookbehind, then attempts to match that single pattern on the reversed string. Therefore, in\xa0",(0,o.kt)("em",{parentName:"p"},"123Z"),", to try the lookbehind at the point before\xa0",(0,o.kt)("em",{parentName:"p"},"Z"),", it reverses the portion of string to be tested from\xa0",(0,o.kt)("em",{parentName:"p"},"123"),"\xa0to\xa0",(0,o.kt)("em",{parentName:"p"},"321"),". Likewise, the lookbehind\xa0(?<\\=(","\\","d{1,5}))\xa0is flipped into the lookahead\xa0(?=(","\\","d{1,5})).\xa0","\\","d{1,5}\xa0matches\xa0",(0,o.kt)("em",{parentName:"p"},"321"),". Reversing that string, Group 1 contains\xa0",(0,o.kt)("em",{parentName:"p"},"123"),". To only capture\xa0",(0,o.kt)("em",{parentName:"p"},"3"),"\xa0as in Java, you would have to make the quantifier lazy:\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=(\\d{1,5}?))Z"),"  "),(0,o.kt)("p",null,"\u273d Like .NET, the\xa0",(0,o.kt)("em",{parentName:"p"},"regex"),"\xa0alternate regular expressions module for Python captures\xa0",(0,o.kt)("em",{parentName:"p"},"123"),"\xa0to Group 1.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Workarounds"),(0,o.kt)("br",{parentName:"p"}),"\n","There are two main workarounds to the lack of support for variable-width (or infinite-width) lookbehind:  "),(0,o.kt)("p",null,"\u273d Capture groups.",(0,o.kt)("br",{parentName:"p"}),"\n","Instead of\xa0(?<\\=","\\","b","\\","d+","_",")","[","A-Z","]","+\xa0, you can use\xa0","\\","b","\\","d+","_","(","[","A-Z","]","+), which matches the digits and underscore you don't want to see, then matches and captures to Group 1 the uppercase text you want to inspect. This will work in all major regex flavors.  "),(0,o.kt)("p",null,"\u273d The\xa0","\\",'K\xa0"keep out" verb, which is available in Perl, PCRE (C, PHP, R\u2026), Ruby 2+ and Python',"\\","'s alternate\xa0",(0,o.kt)("a",{parentName:"p",href:"https://pypi.python.org/pypi/regex"},(0,o.kt)("em",{parentName:"a"},"regex"),"\xa0engine"),".",(0,o.kt)("br",{parentName:"p"}),"\n","\\","K\xa0tells the engine to drop whatever it has matched so far from the match to be returned. Instead of\xa0(?<\\=","\\","b","\\","d+","_",")","[","A-Z","]","+, you can therefore use\xa0","\\","b","\\","d+","_","\\","K","[","A-Z","]","+  "),(0,o.kt)("p",null,"Compared with lookbehinds, both the\xa0","\\","K\xa0and capture group workarounds have limitations:  "),(0,o.kt)("p",null,"\u273d When you look for multiple matches in a string, at the starting position of each match attempt, a lookbehind can inspect the characters behind the current position in the string. Therefore, against\xa0",(0,o.kt)("em",{parentName:"p"},"123"),", the pattern\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=\\d)\\d"),"\xa0(match a digit preceded by a digit) will match both\xa0",(0,o.kt)("em",{parentName:"p"},"2"),"\xa0and\xa0",(0,o.kt)("em",{parentName:"p"},"3"),". In contrast,\xa0",(0,o.kt)("em",{parentName:"p"},"\\","d","\\","K","\\","d"),"\xa0can only match\xa0",(0,o.kt)("em",{parentName:"p"},"2"),", as the starting position after the first match is immediately before the\xa0",(0,o.kt)("em",{parentName:"p"},"3"),", and there are not enough digits left for a second match. Likewise,\xa0","\\","d(","\\","d)\xa0can only capture\xa0",(0,o.kt)("em",{parentName:"p"},"2"),".  "),(0,o.kt)("p",null,"\u273d With lookbehinds, you can impose multiple conditions (similar to our\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#password"},"password validation technique"),") by using multiple lookbehinds. For instance, to match a digit that is preceded by a lower-case Greek letter, you can use\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"(?<=\\p{Ll})(?<=\\p{Greek})\\d"),". The first lookbehind\xa0(?<\\=","\\","p{Ll})\xa0ensures that the character immediately to the left is a lower-case letter, and the second lookbehind\xa0(?<\\=","\\","p{Greek})\xa0ensures that the character immediately to the left belongs to the Greek script. With the workarounds, you could use\xa0","\\","p{Greek}","\\","K","\\","d\xa0to match a digit preceded by a character in the Greek script (or\xa0","\\","p{Greek}(","\\","d)\xa0to capture it), but you cannot impose a second condition. To get over this limitation, you could capture the Greek character and use a second regex to check that it is a lower-case letter.  "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#anchor"},"(direct link)"),"  "),(0,o.kt)("h2",{id:"lookarounds-usually-want-to-be-anchored"},"Lookarounds (Usually) Want to be Anchored"),(0,o.kt)("p",null,"Let's imagine we want to match a string consisting of one word, provided it contains at least one digit. This pattern offers a reasonable solution\u2014one of several:",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"\\A(?=\\D*\\d)\\w+\\z"),(0,o.kt)("br",{parentName:"p"}),"\n","The\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-anchors.html#A"},"\\","A\xa0anchor"),"\xa0asserts that the current position is the beginning of the string. The lookahead\xa0(?=","\\","D","*","\\","d)\xa0asserts that at the current position (which is still the beginning of the string), we can match zero or more non-digits, then one digit. Next,\xa0","\\","w+\xa0matches our word. Finally, the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-anchors.html#z"},"\\","z\xa0anchor"),"\xa0asserts that the current position is the end of the string.  "),(0,o.kt)("p",null,"Now consider what happens when we forget the anchor\xa0","\\","A\xa0and use\xa0(?=","\\","D","*","\\","d)","\\","w+","\\","z. To make our oversight seem less severe, let's assume we know that our string always contains an uninterrupted string of word characters. This guarantees that if we find a match, it will have to be the right one\u2014at the beginning of the string, as we wanted. So what's the problem?  "),(0,o.kt)("p",null,"Suppose we use our regex on a string composed of one hundred characters\xa0",(0,o.kt)("em",{parentName:"p"},"V"),". Since the string doesn't contain a single digit, you and I can immediately see that the regex must fail. Let's see how fast the engine comes to the same conclusion.  "),(0,o.kt)("p",null,"As always, the engine begins by trying to match the pattern at the first position in the string. Starting with the first token\xa0(?=","\\","D","*","\\","d), it tries to assert that at the current position, i.e. the beginning of the string, it can match zero or more non-digits, then one digit. Within the subexpression, the\xa0","\\","D","*","\xa0matches all the\xa0",(0,o.kt)("em",{parentName:"p"},"V"),"\xa0characters. The engine then tries to match a digit, but since we have reached the end of the string, that fails.  "),(0,o.kt)("p",null,"If we're using a smart engine such as PCRE, at this stage the engine fails the lookaround for this first match attempt. That's because before starting the match attempt, the engine has studied the pattern and noticed that the\xa0","\\","D\xa0and\xa0","\\","d\xa0tokens are mutually exclusive, and it has turned the\xa0","*","\xa0quantifier into a possessive quantifier\xa0","*","+, a process known to PCRE as\xa0",(0,o.kt)("em",{parentName:"p"},"auto-possessification"),"\xa0(see\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#atomic"},"footnote"),").  "),(0,o.kt)("p",null,"A less clever engine will backtrack, giving up all the\xa0","\\","D\xa0characters it has matched one by one, each time attempting to match a\xa0","\\","d\xa0after giving up a\xa0","\\","D. Eventually, the engine runs out of characters to backtrack, and the lookahead fails.  "),(0,o.kt)("p",null,"Once the engine understands that the lookahead must fail (whether it comes to this conclusion cleverly or clumsily), it gives up on the entire first match attempt. Next, as always in such cases, the engine moves to the next position in the string (past the first\xa0",(0,o.kt)("em",{parentName:"p"},"V"),") and starts a new match attempt. Again, the\xa0","\\","D","*","\xa0eats up all the\xa0",(0,o.kt)("em",{parentName:"p"},"V"),"\xa0characters\u2014although this time, there are only 99 of them. Again, the lookahead fails, either fast if the engine is smart, or, more likely, after backtracking all the way back to the starting position.  "),(0,o.kt)("p",null,"After failing a second time, the engine moves past the second\xa0",(0,o.kt)("em",{parentName:"p"},"V"),", starts a new match attempt, and fails\u2026 And so on, all the way to the end of the string.  "),(0,o.kt)("p",null,"Because the pattern is not anchored at the beginning of the string, at each match attempt, the engine checks whether the lookahead matches at the current position. In doing so, in the best case, it matches 100\xa0",(0,o.kt)("em",{parentName:"p"},"V"),"\xa0characters, then 99 on the second attempt, and so on\u2014so it needs about 5000 steps before it can see that the pattern will never match. In the more usual case, the engine needs to backtrack and try the\xa0","\\","d\xa0at each position, adding two steps at each\xa0",(0,o.kt)("em",{parentName:"p"},"V position"),". Altogether, it needs about 15,000 steps before it can see that the pattern will never match.  "),(0,o.kt)("p",null,"In contrast, with the original anchored pattern\xa0","\\","A(?=","\\","D","*","\\","d)","\\","w+","\\","z, after the engine fails the first match attempt, each of the following match attempts at further positions in the string fail instantly, because the\xa0","\\","A\xa0fails before the engine gets to the lookahead. In the best case, the engine takes about 200 steps to fail (100 steps to match all the\xa0",(0,o.kt)("em",{parentName:"p"},"V"),"\xa0characters, then one step at each of the further match attempts.) In the more usual case, the engine takes about 400 steps to fail (300 steps on the first match attempt, then one step at each of the further match attempts.)  "),(0,o.kt)("p",null,"Needless to say, the ratio of (15,000 / 400) steps is the kind of performance hit we try to avoid in computing. This makes a solid case for helping the engine along by minimizing the number of times lookaheads must be attempted, either by using\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-anchors.html"},"anchors"),"\xa0such as\xa0^\xa0and\xa0","\\","A, or by matching literal characters immediately before the lookahead.  "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"One Exception: Overlapping Matches"),(0,o.kt)("br",{parentName:"p"}),"\n","There are times when we do want the engine to attempt the lookahead at every single position in the string. Usually, the purpose of such a maneuver is to match a number of overlapping substrings. For instance, against the string\xa0word, if the regex\xa0(?=(","\\","w+))\xa0is allowed to match repeatedly, it will match four times, and each match will capture a different string to Group 1:\xa0",(0,o.kt)("em",{parentName:"p"},"word"),",\xa0",(0,o.kt)("em",{parentName:"p"},"ord"),",\xa0",(0,o.kt)("em",{parentName:"p"},"rd"),", then\xa0",(0,o.kt)("em",{parentName:"p"},"d"),". The section on\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-lookarounds.html#overlapping"},"overlapping matches"),"\xa0explains how this works.  "),(0,o.kt)("h2",{id:"footnotes"},"Footnotes"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Atomic tweak"),(0,o.kt)("br",{parentName:"p"}),"\n","The\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-disambiguation.html#atomic"},"atomic"),"\xa0variation\xa0(?",">","[","^a-z","]","*",")","[","a-z","]","\xa0or\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-quantifiers.html#possessive"},"possessive"),"\xa0version\xa0","[","^a-z","]","*","+","[","a-z","]",'\xa0are tweaks that ensure that if the engine fails to find the lowercase letter, it won\'t "stupidly" backtrack, giving up the non-lowercase letters one by one to see if a lowercase letter might fit at that stage.  '),(0,o.kt)("p",null,"Note that before they start matching, some engines notice the mutually exclusive character of\xa0","[","a-z","]","\xa0and its counterclass and automatically make the\xa0","*","\xa0quantifier possessive for you. This optimization is what PCRE calls\xa0",(0,o.kt)("em",{parentName:"p"},"auto-possessification"),". It allows you to turn it off with the\xa0",(0,o.kt)("a",{parentName:"p",href:"https://www.rexegg.com/regex-modifiers.html#pcre"},"Special Start-of-Pattern Modifier"),"\xa0(","*","NO","_","AUTO","_","POSSESS)\u2014but why would you ever want to?"))}m.isMDXComponent=!0}}]);
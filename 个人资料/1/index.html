<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-个人资料/1">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Mastering Lookahead and Lookbehind | 质量管理体系学习资料</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://360study.github.io/个人资料/1"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="keywords" content="QMS,EMS,质量管理,质量管理体系,CCAA,审核员"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Mastering Lookahead and Lookbehind | 质量管理体系学习资料"><meta data-rh="true" name="description" content="[![Page copy protected against web site content"><meta data-rh="true" property="og:description" content="[![Page copy protected against web site content"><link data-rh="true" rel="canonical" href="https://360study.github.io/个人资料/1"><link data-rh="true" rel="alternate" href="https://360study.github.io/个人资料/1" hreflang="en"><link data-rh="true" rel="alternate" href="https://360study.github.io/个人资料/1" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.d69d34ad.css">
<link rel="preload" href="/assets/js/runtime~main.9ccc41ac.js" as="script">
<link rel="preload" href="/assets/js/main.efaa865f.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">QMS学习网站</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/ISO9001">ISO9001</a><a class="navbar__item navbar__link" href="/ISO14001">ISO14001</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Community</a><ul class="dropdown__menu"><li><a href="https://www.facebook.com" target="_blank" rel="noopener noreferrer" class="dropdown__link">Facebook<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a class="dropdown__link" href="/ISO14001">ISO14001</a></li><li><a class="dropdown__link" href="/ISO9001">ISO9001</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/"><b>QMS学习网站</b></a><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Home</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/category/个人资料">个人资料</a><button aria-label="Toggle the collapsible sidebar category &#x27;个人资料&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/个人资料/0、引言">0、引言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/个人资料/1">Mastering Lookahead and Lookbehind</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/个人资料/th">处置的定义</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/个人资料/正则表达式">正则表达式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/个人资料/油猴延迟执行">油猴延迟执行</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/个人资料/质量管理体系中的评价与评审">质量管理体系中的评价与评审</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/xuexi_index">学习资料</a><button aria-label="Toggle the collapsible sidebar category &#x27;学习资料&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/category/评审相关">评审相关</a><button aria-label="Toggle the collapsible sidebar category &#x27;评审相关&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/安标受控件">安标受控件</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/工厂评审不合格项">工厂评审不合格项</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/工厂评审相关问题">工厂评审相关问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/工艺过程卡">工艺过程卡片，工序卡片，工艺卡，刀具卡区别</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/工装验证">工装验证</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/校准设备">校准设备</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/矿用产品安全标志现场评审准则">矿用产品安全标志现场评审准则</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/重要组成部分的可追溯性">可追溯性的保证</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/问题清单">问题清单</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/评审相关/问题清单1">问题清单1</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/category/质量管理体系基础">质量管理体系基础</a><button aria-label="Toggle the collapsible sidebar category &#x27;质量管理体系基础&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" tabindex="0" href="/质量管理体系基础/ISO9000/">ISO190000-2015</a><button aria-label="Toggle the collapsible sidebar category &#x27;ISO190000-2015&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/ISO9000 族标准-0">0、ISO9000 族标准</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/1、 有关人员的术语">1、 有关人员的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/2、有关组织的术语">2、有关组织的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/3、有关活动的术语">3、有关活动的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/4、有关过程的术语">4、有关过程的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/5、有关体系的术语">5、有关体系的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/ISO9000 标准与术语-6">6、有关要求的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/7、有关结果的术语">7、有关结果的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/8、有关数据、信息和文件的术语">8、有关数据、信息和文件的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/9、有关顾客的术语">9、有关顾客的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/10、有关特性的术语">10、有关特性的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/11、有关确定的术语">11、有关确定的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/12、有关措施的术语">12、有关措施的术语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/质量管理体系基础/ISO9000/13、有关审核的术语">13、有关审核的术语</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/质量管理体系基础/ISO14001/">ISO 14001:2015</a><button aria-label="Toggle the collapsible sidebar category &#x27;ISO 14001:2015&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/质量管理体系基础/ISO45001/">ISO45001</a><button aria-label="Toggle the collapsible sidebar category &#x27;ISO45001&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/质量管理体系基础/ISO9001/质量管理体系考试大纲">ISO9001</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/质量管理体系基础/书籍/企业新版质量管理体系标准普及读本_郭庆华编著">书籍</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/质量管理体系基础/合格评定相关法律法规/1、计量法">合格评定相关法律法规</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/质量管理体系基础/考试大纲/CCAA-TR-102-01管理体系认证基础">考试大纲</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/质量管理体系基础/质量管理工具/1、综述">质量管理工具</a></div></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/category/个人资料"><span itemprop="name">个人资料</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Mastering Lookahead and Lookbehind</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Mastering Lookahead and Lookbehind</h1><p><a href="http://www.copyscape.com/" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://d1go27vtttaqyn.cloudfront.net/copyscape-white.gif" alt="Page copy protected against web site content
infringement by Copyscape" title="Do not copy content from the page.
Plagiarism will be detected by Copyscape." class="img_ev3q"></a></p><p>Lookarounds often cause confusion to the regex apprentice. I believe this confusion promptly disappears if one simple point is firmly grasped. It is that at the end of a lookahead or a lookbehind, the regex engine hasn&#x27;t moved on the string. You can chain three more lookaheads after the first, and the regex engine still won&#x27;t move. In fact, that&#x27;s a useful technique.  </p><p><strong>A quick syntax reminder</strong><br>
<!-- -->This page digs deep into the details of lookahead and lookbehind and assumes you&#x27;ve already become familiar with the basic syntax, perhaps by reading the <a href="https://www.rexegg.com/regex-disambiguation.html#lookarounds" target="_blank" rel="noopener noreferrer">lookaround section</a> of the reference on (? … ) syntax. As a quick reminder before we dive in, here are the four lookarounds.  </p><table><thead><tr><th><strong> Lookaround 	</strong></th><th><strong>Name </strong></th><th><strong>What it Does</strong></th></tr></thead><tbody><tr><td>(?=foo)</td><td>Lookahead</td><td>Asserts that what immediately follows the current position in the string is foo</td></tr><tr><td>(?&lt;=foo)</td><td>Lookbehind</td><td>Asserts that what immediately precedes the current position in the string is foo</td></tr><tr><td>(?!foo)</td><td>Negative Lookahead</td><td>Asserts that what immediately follows the current position in the string is not foo</td></tr><tr><td>(?&lt;!foo)</td><td>Negative Lookbehind</td><td>Asserts that what immediately precedes the current position in the string is not foo</td></tr></tbody></table><p>Lookaround	Name	What it Does
(?=foo)	Lookahead	Asserts that what immediately follows the current position in the string is foo
(?&lt;=foo)	Lookbehind	Asserts that what immediately precedes the current position in the string is foo
(?!foo)	Negative Lookahead	Asserts that what immediately follows the current position in the string is not foo
(?&lt;!foo)	Negative Lookbehind	Asserts that what immediately precedes the current position in the string is not foo</p><p><a href="https://www.rexegg.com/regex-lookarounds.html#nav" target="_blank" rel="noopener noreferrer">(direct link)</a><br>
<strong>Jumping Points</strong><br>
<!-- -->For easy navigation, here are some jumping points to various sections of the page:  </p><p>✽ <a href="https://www.rexegg.com/regex-lookarounds.html#password" target="_blank" rel="noopener noreferrer">Lookahead Example: Simple Password Validation</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#order" target="_blank" rel="noopener noreferrer">The Order of Lookaheads Doesn&#x27;t Matter… Almost</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#stand_their_ground" target="_blank" rel="noopener noreferrer">Lookarounds Stand their Ground</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#uses" target="_blank" rel="noopener noreferrer">Various Uses for Lookarounds</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#zero_width" target="_blank" rel="noopener noreferrer">Zero-Width Matches</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#position" target="_blank" rel="noopener noreferrer">Positioning the Lookaround Before or After the Characters to be Matched</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#back_to_the_future" target="_blank" rel="noopener noreferrer">Lookarounds that Look on Both Sides: Back to the Future</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#compound" target="_blank" rel="noopener noreferrer">Compound Lookahead and Compound Lookbehind</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#atomic" target="_blank" rel="noopener noreferrer">The Engine Doesn&#x27;t Backtrack into Lookarounds (They&#x27;re Atomic)</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#width" target="_blank" rel="noopener noreferrer">Fixed-Width, Constrained-Width and Infinite-Width Lookbehind</a><br>
<!-- -->✽ <a href="https://www.rexegg.com/regex-lookarounds.html#anchor" target="_blank" rel="noopener noreferrer">Lookarounds (Usually) Want to be Anchored</a>  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#password" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="lookahead-example-simple-password-validation">Lookahead Example: Simple Password Validation<a href="#lookahead-example-simple-password-validation" class="hash-link" aria-label="Direct link to Lookahead Example: Simple Password Validation" title="Direct link to Lookahead Example: Simple Password Validation">​</a></h2><p>Let&#x27;s get our feet wet right away with an expression that validates a password. The technique shown here will be useful for all kinds of other data you might want to validate (such as email addresses or phone numbers).<br>
<!-- -->Our password must meet four conditions:  </p><p>1<!-- -->.<!-- --> The password must have between six and ten word characters <!-- -->\<!-- -->w<br>
<!-- -->2<!-- -->.<!-- --> It must include at least one lowercase character <!-- -->[<!-- -->a-z<!-- -->]<br>
<!-- -->3<!-- -->.<!-- --> It must include at least <strong>three</strong> uppercase characters <!-- -->[<!-- -->A-Z<!-- -->]<br>
<!-- -->4<!-- -->.<!-- --> It must include at least one digit <!-- -->\<!-- -->d  </p><p>We&#x27;ll assume we&#x27;re working in a regex flavor where <!-- -->\<!-- -->d only matches ASCII digits 0 through 9, unlike .NET and Python where that token can match any Unicode digit.  </p><p>With lookarounds, your feet stay planted on the string. You&#x27;re just looking, not moving!</p><p>Our initial strategy (which we&#x27;ll later tweak) will be to stand at the beginning of the string and <strong>look ahead</strong> four times—once for each condition. We&#x27;ll look to check we have the right number of characters, then we&#x27;ll look for a lowercase letter, and so on. If all the lookaheads are successful, we&#x27;ll know the string is a valid password… And we&#x27;ll simply gobble it all up with a plain .<!-- -->*<!-- -->  </p><p><strong>Let&#x27;s start with condition 1</strong><br>
<!-- -->A string that is made of six-to-ten word characters can be written like this: <!-- -->\<!-- -->A<!-- -->\<!-- -->w{6,10}<!-- -->\<!-- -->z<br>
<!-- -->The <a href="https://www.rexegg.com/regex-anchors.html#A" target="_blank" rel="noopener noreferrer">\<!-- -->A anchor</a> asserts that the current position is the beginning of the string. After matching the six to ten word characters, the <a href="https://www.rexegg.com/regex-anchors.html#z" target="_blank" rel="noopener noreferrer">\<!-- -->z anchor</a> asserts that the current position is the end of the string.  </p><p>Within a lookahead, this pattern becomes (?=<!-- -->\<!-- -->A<!-- -->\<!-- -->w{6,10}<!-- -->\<!-- -->z). This lookahead asserts: at the current position in the string, what follows is the beginning of the string, six to ten word characters, and the very end of the string.  </p><p>We want to make this assertion at the very beginning of the string. Therefore, to continue building our pattern, we want to anchor the lookahead with an <!-- -->\<!-- -->A. There is no need to duplicate the <!-- -->\<!-- -->A, so we can take it out of the lookahead. Our pattern becomes:<br>
<code>\A(?=\w{6,10}\z)</code><br>
<!-- -->So far, we have an expression that validates that a string is entirely composed of six to ten word characters. Note that we haven&#x27;t matched any of these characters yet: we have only looked ahead. The current position after the lookahead is still the beginning of the string. To check the other conditions, we just add lookaheads.  </p><p><strong>Condition 2</strong><br>
<!-- -->For our second condition, we need to check that the password contains one lowercase letter. To find one lowercase letter, the simplest idea is to use .<!-- -->*<!-- -->[<!-- -->a-z<!-- -->]<!-- -->. That works, but the dot-star first shoots down to the end of the string, so we will always need to backtrack. Just for the sport, can we think of something more efficient? You might think of making the star quantifier reluctant by adding a ?, giving us .<!-- -->*<!-- -->?<!-- -->[<!-- -->a-z<!-- -->]<!-- -->, but that too requires backtracking as a <a href="https://www.rexegg.com/regex-quantifiers.html#lazy_expensive" target="_blank" rel="noopener noreferrer">lazy quantifier requires backtracking at each step</a>.  </p><p>For this type of situation, I recommend you use something like <!-- -->[<!-- -->^a-z<!-- -->]<!-- -->*<!-- -->[<!-- -->a-z<!-- -->]<!-- --> (or even better, depending on your engine, the <a href="https://www.rexegg.com/regex-disambiguation.html#atomic" target="_blank" rel="noopener noreferrer">atomic</a> (?<!-- -->&gt;<!-- -->[<!-- -->^a-z<!-- -->]<!-- -->*<!-- -->)<!-- -->[<!-- -->a-z<!-- -->]<!-- --> or <a href="https://www.rexegg.com/regex-quantifiers.html#possessive" target="_blank" rel="noopener noreferrer">possessive</a> version <!-- -->[<!-- -->^a-z<!-- -->]<!-- -->*<!-- -->+<!-- -->[<!-- -->a-z<!-- -->]<!-- -->—but we&#x27;ll discuss that in the <a href="https://www.rexegg.com/regex-lookarounds.html#atomictweak" target="_blank" rel="noopener noreferrer">footnotes</a>). The negated character class <!-- -->[<!-- -->^a-z<!-- -->]<!-- --> is the <em>counterclass</em> of the lowercase letter <!-- -->[<!-- -->a-z<!-- -->]<!-- --> we are looking for: it matches one character that is not a lowercase letter, and the <!-- -->*<!-- --> quantifier makes us match zero or more such characters. The pattern <!-- -->[<!-- -->^a-z<!-- -->]<!-- -->*<!-- -->[<!-- -->a-z<!-- -->]<!-- --> is a good example of the principle of <a href="https://www.rexegg.com/regex-style.html#contrast" target="_blank" rel="noopener noreferrer">contrast</a> recommended by the regex style guide.  </p><p>Let&#x27;s use this pattern inside a lookahead: (?=<!-- -->[<!-- -->^a-z<!-- -->]<!-- -->*<!-- -->[<!-- -->a-z<!-- -->]<!-- -->)<br>
<!-- -->The lookahead asserts: at this position in the string (i.e., the beginning of the string), we can match zero or more characters that are not lowercase letters, then we can match one lowercase letter: <!-- -->[<!-- -->a-z<!-- -->]<br>
<!-- -->Our pattern becomes:<br>
<code>\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])</code><br>
<!-- -->At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead twice. We still haven&#x27;t matched any characters. Note that on a logical level it doesn&#x27;t matter which condition we check first. If we swapped the order of the lookaheads, the result would be the same.  </p><p>We have two more conditions to satisfy: two more lookaheads.  </p><p><strong>Condition 3</strong><br>
<!-- -->For our third condition, we need to check that the password contains at least three uppercase letters. The logic is similar to condition 2: we look for an optional number of non-uppercase letters, then one uppercase letter… But we need to repeat that three times, for which we&#x27;ll use the quantifier {3}.<br>
<!-- -->We&#x27;ll use this lookahead: (?=(?:<!-- -->[<!-- -->^A-Z<!-- -->]<!-- -->*<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->){3})  </p><p>The lookahead asserts: at this position in the string (i.e., the beginning of the string), we can do the following three times: match zero or more characters that are not uppercase letters (the job of the negated character class <!-- -->[<!-- -->^A-Z<!-- -->]<!-- --> with the quantifier <!-- -->*<!-- -->), then match one uppercase letter: <!-- -->[<!-- -->A-Z<!-- -->]<br>
<!-- -->Our pattern becomes:<br>
<code>\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})</code><br>
<!-- -->At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead three times. We still haven&#x27;t matched any characters.  </p><p><strong>Condition 4</strong><br>
<!-- -->To check that the string contains at least one digit, we use this lookahead: (?=<!-- -->\<!-- -->D<!-- -->*<!-- -->\<!-- -->d). Opposing <!-- -->\<!-- -->d to its counterclass <!-- -->\<!-- -->D makes good use of the <a href="https://www.rexegg.com/regex-style.html#contrast" target="_blank" rel="noopener noreferrer">regex principle of contrast</a>.  </p><p>The lookahead asserts: at this position in the string (i.e., the beginning of the string), we can match zero or more characters that are not digits (the job of the &quot;not-a-digit&quot; character class <!-- -->\<!-- -->D and the <!-- -->*<!-- --> quantifier), then we can match one digit: <!-- -->\<!-- -->d<br>
<!-- -->Our pattern becomes:<br>
<code>\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d)</code><br>
<!-- -->At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead four times to check our four conditions. We still haven&#x27;t matched any characters, but we have validated our string: we know that it is a valid password.  </p><p>If all we wanted was to validate the password, we could stop right there. But if for any reason we also need to match and return the entire string—perhaps because we ran the regex on the output of a function and the password&#x27;s characters haven&#x27;t yet been assigned to a variable—we can easily do so now.  </p><p><strong>Matching the Validated String</strong><br>
<!-- -->After checking that the string conforms to all four conditions, we are still standing at the beginning of the string. The five assertions we have made (the anchor <!-- -->\<!-- -->A and the four lookaheads) have not changed our position. At this stage, we can use a simple .<!-- -->*<!-- --> to gobble up the string: we know that whatever characters are matched by the dot-star, the string is a valid password. The pattern becomes:<br>
<code>\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d).*</code><br>
<a href="https://www.rexegg.com/regex-lookarounds.html#n-1conds" target="_blank" rel="noopener noreferrer">(direct link)</a><br>
<strong>Fine-Tuning: Removing One Condition</strong>  </p><p>For n conditions,<br>
<!-- -->use n-1 lookaheads</p><p>If you examine our lookaheads, you may notice that the pattern <!-- -->\<!-- -->w{6,10}<!-- -->\<!-- -->z inside the first one examines all the characters in the string. Therefore, we could have used this pattern to match the whole string instead of the dot-star .<!-- -->*<!-- -->  </p><p>This allows us to remove one lookahead and to simplify the pattern to this:  </p><p><code>\A(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d)\w{6,10}\z</code><br>
<!-- -->The pattern <!-- -->\<!-- -->w{6,10}<!-- -->\<!-- -->z now serves the double purpose of matching the whole string and of ensuring that the string is entirely composed of six to ten word characters.  </p><p>Generalizing this result, if you must check for n conditions, your pattern only needs to include n-1 lookaheads at the most. Often, you are even able to combine several conditions into a single lookahead.  </p><p>You may object that we were able to use <!-- -->\<!-- -->w{6,10}<!-- -->\<!-- -->z because it happened to match the whole string. Indeed that was the case. But we could also have converted any of the other three lookaheads to match the entire string. For instance, taking the lookahead (?=<!-- -->\<!-- -->D<!-- -->*<!-- -->\<!-- -->d) which checks for the presence of one digit, we can add a simple .<!-- -->*<!-- -->\<!-- -->z to get us to the end of the string.  </p><p>The pattern would have become:<br>
<code>\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})\D*\d.*\z</code><br>
<!-- -->By the way, you may wonder why I bother using the <!-- -->\<!-- -->z after the .<!-- -->*<!-- -->: shouldn&#x27;t it get me to the end of the string? In general, not so: unless we&#x27;re in <a href="https://www.rexegg.com/regex-modifiers.html#dotall" target="_blank" rel="noopener noreferrer">DOTALL mode</a>, the dot doesn&#x27;t match line breaks. Therefore, the .<!-- -->*<!-- --> only gets you to the end of the first line. After this, the string may have line breaks and many more line. A <!-- -->\<!-- -->z anchor ensures that after the .<!-- -->*<!-- --> we have reached not only the end of the line, but also the end of the string.  </p><p>In this particular pattern, the first lookaround (?=<!-- -->\<!-- -->w{6,10}<!-- -->\<!-- -->z) already ensures that there cannot be any line breaks in the string, so the final <!-- -->\<!-- -->z is not strictly necessary.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#order" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="the-order-of-lookaheads-doesnt-matter-almost">The Order of Lookaheads Doesn&#x27;t Matter… Almost<a href="#the-order-of-lookaheads-doesnt-matter-almost" class="hash-link" aria-label="Direct link to The Order of Lookaheads Doesn&#x27;t Matter… Almost" title="Direct link to The Order of Lookaheads Doesn&#x27;t Matter… Almost">​</a></h2><p>In our password validation pattern, since the three lookaheads don&#x27;t change our position in the string, we can rearrange them in any order without affecting the overall logic.  </p><p>While the order of lookaheads doesn&#x27;t matter on a logical level, keep in mind that it may matter for matching speed. If one lookahead is more likely to fail than the other two, it makes little sense to place it in third position and expend a lot of energy checking the first two conditions. Make it first, so that if we&#x27;re going to fail, we fail early—an application of the <a href="https://www.rexegg.com/regex-style.html#design_to_fail" target="_blank" rel="noopener noreferrer"><em>design to fail</em> principle</a> from the regex style guide.  </p><p>In fact, this is what we do by placing the anchor <!-- -->\<!-- -->A in first position. Since it is an assertion that doesn&#x27;t consume characters, it too could swap positions with any of the lookaheads. We&#x27;ll see why this is a bad idea, but first…  </p><p>In passing, consider that <!-- -->\<!-- -->A can be written with lookarounds: in <a href="https://www.rexegg.com/regex-modifiers.html#dotall" target="_blank" rel="noopener noreferrer">DOTALL mode</a>, where the dot matches any character including line breaks, the negative lookbehind (?&lt;!.) asserts that what precedes the current position is not <em>any character</em>—therefore the position must be the beginning of the string. Without DOTALL mode, the negative lookbehind (?&lt;!<!-- -->[<!-- -->\<!-- -->D<!-- -->\<!-- -->d<!-- -->]<!-- -->) asserts the same, since <!-- -->[<!-- -->\<!-- -->D<!-- -->\<!-- -->d<!-- -->]<!-- --> matches one character that is either a digit or a non-digit—in other words, any character.  </p><p>Now imagine we set <!-- -->\<!-- -->A in fourth position, after the three lookaheads. The resulting match would be the same, but it could take a lot more time. For instance, suppose the third lookahead (whose job it is to assert that the string contains at least one digit) fails. After failing to find a match at the first position in the string, the engine advances to the second position and tries the lookaheads again, one after the other. Once more, the third lookahead is bound to fail to find a digit. After each failure, the engine will start a new match attempt starting at the next position in the string. Even when the two first lookaheads succeed (and they may fail, as the uppercase or lowercase letter they check for may have been the lone one in the string, and at a position already passed), the third lookahead will always fail to find a digit. Therefore the anchor <!-- -->\<!-- -->A is never even attempted: the pattern fails before the engine reaches that token.  </p><p>In contrast, when <!-- -->\<!-- -->A is first, it can only match at the first position in the string. The third lookahead still fails, but when the engine tries to match at further positions, the <!-- -->\<!-- -->A immediately fails, so the engine doesn&#x27;t need to waste any more time with the lookaheads.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#stand_their_ground" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="lookarounds-stand-their-ground">Lookarounds Stand their Ground<a href="#lookarounds-stand-their-ground" class="hash-link" aria-label="Direct link to Lookarounds Stand their Ground" title="Direct link to Lookarounds Stand their Ground">​</a></h2><p>If I seem to be flogging a dead horse here, it&#x27;s only because this point is the most common source of confusion with lookarounds. As the password validation example made clear, lookarounds stand their ground. They look immediately to the left or right of the engine&#x27;s current position on the string—but do not alter that position.  </p><p>Therefore, do not expect the pattern A(?=5) to match the <em>A</em> in the string <em>AB25</em>. Many beginners assume that the lookahead says that &quot;there is a <em>5</em> somewhere to the right&quot;, but that is not so. After the engine matches the <em>A</em>, the lookahead (?=5) asserts that at the current position in the string, what immediately follows is a <em>5</em>. If you want to check if there is a <em>5</em> somewhere (anywhere) to the right, you can use (?=<!-- -->[<!-- -->^5<!-- -->]<!-- -->*<!-- -->5).  </p><p>Moreover, don&#x27;t expect the pattern A(?=5)(?=<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->) to match the <em>A</em> in the string <em>A5B</em>. Many beginners assume that the second lookahead looks to the right of the first lookahead. It is not so. At the end of the first lookahead, the engine is still planted at the very same spot in the string, after the <em>A</em>. When the lookahead (?=<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->) tries to assert that what immediately follows the current position is an uppercase letter, it fails because the next character is still the <em>5</em>. If you want to check that the 5 is followed by an uppercase letter, just state it in the first lookahead: (?=5<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->)  </p><p>So <em>lookahead</em> and <em>lookbehind</em> don&#x27;t mean &quot;look way ahead into the distance&quot;. They mean &quot;look at the text immediately to the left or to the right&quot;. If you want to inspect a piece of string further down, you will need to insert &quot;binoculars&quot; inside the lookahead to get you to the part of the string you want to inspect—for instance a .<!-- -->*<!-- -->, or, ideally, more specific tokens.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#uses" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="various-uses-for-lookarounds">Various Uses for Lookarounds<a href="#various-uses-for-lookarounds" class="hash-link" aria-label="Direct link to Various Uses for Lookarounds" title="Direct link to Various Uses for Lookarounds">​</a></h2><p>Before we dive into interesting but sometimes terse details, let&#x27;s get excited about lookarounds by surveying some of their terrific uses.  </p><p><strong>Validation</strong><br>
<!-- -->The <a href="https://www.rexegg.com/regex-lookarounds.html#password" target="_blank" rel="noopener noreferrer">password validation</a> section showed how the combination of several lookaheads can impose a number of conditions on the string to be matched, allowing us to validate it with a single pattern.  </p><p><strong>Restricting a Character Range (Subtraction, Intersection)</strong><br>
<!-- -->Suppose you want to match one word character <!-- -->\<!-- -->w as long as it is not the letter <em>Q</em>. There are several ways to do it without lookarounds:<br>
<!-- -->✽ In engines that support <a href="https://www.rexegg.com/regex-class-operations.html#subtraction" target="_blank" rel="noopener noreferrer">character class subtraction</a>, you can use <!-- -->[<!-- -->\<!-- -->w-<!-- -->[<!-- -->Q<!-- -->]<!-- -->]<!-- --> (.NET), <!-- -->[<!-- -->\<!-- -->w&amp;&amp;<!-- -->[<!-- -->^Q<!-- -->]<!-- -->]<!-- --> (Java and Ruby 1.9+) or <!-- -->[<!-- -->\<!-- -->w--Q<!-- -->]<!-- --> (Python with the alternate <em>regex</em> module)<br>
<!-- -->✽ You can build a character class such as <!-- -->[<!-- -->_<!-- -->0-9a-zA-PR-Z<!-- -->]<br>
<!-- -->✽ You can use <!-- -->[<!-- -->^<!-- -->\<!-- -->WQ<!-- -->]<!-- -->—an example of an <a href="https://www.rexegg.com/regex-interesting-character-classes.html#obnoxious" target="_blank" rel="noopener noreferrer">obnoxious double-negative character range</a>.  </p><p>If your engine doesn&#x27;t support character class subtraction, the simplest may be to use the <a href="https://www.rexegg.com/regex-class-operations.html#subtraction_workaround" target="_blank" rel="noopener noreferrer">workaround</a> shown on the page about class operations. This uses a lookahead to restrict the character class <!-- -->\<!-- -->w:<br>
<code>(?!Q)\w</code>After the negative lookahead asserts that what follows the current position is not a <em>Q</em>, the <!-- -->\<!-- -->w matches a word character.  </p><p>Not only is this solution easy to read, it is also easy to maintain if we ever decide to exclude the letter <em>K</em> instead of <em>Q</em>, or to exclude both: (?!<!-- -->[<!-- -->QK<!-- -->]<!-- -->)<!-- -->\<!-- -->w  </p><p>Note that we can also perform the same exclusion task with a negative lookbehind:<br>
<code>\w(?&lt;!Q)</code>After the <!-- -->\<!-- -->w matches a word character, the negative lookbehind asserts that what precedes the current position is not a <em>Q</em>.  </p><p>Using the same idea, if we wanted to match one character in the Arabic script as long as it is not a number, we could use this pattern:<br>
<code>(?!\p{N})\p{Arabic}</code>This would work in Perl, PCRE (C, PHP, R…) and Ruby 2+. In .NET and Java, you would use (?!<!-- -->\<!-- -->p{N})<!-- -->\<!-- -->p{IsArabic}  </p><p>Likewise, we can use this technique to perform a DIY <a href="https://www.rexegg.com/regex-class-operations.html#intersection" target="_blank" rel="noopener noreferrer">character class intersection</a>. For instance, to match one character in the Arabic script as long as it is a number, we transform the negative lookahead above to a positive lookahead. In the Perl / PCRE / Ruby version, this gives us:<br>
<code>(?=\p{N})\p{Arabic}</code><br>
<!-- -->This is basically the <a href="https://www.rexegg.com/regex-lookarounds.html#password" target="_blank" rel="noopener noreferrer">password validation technique</a> with two conditions applied to a single character.  </p><p>Needless to say, you can interchange the content of the lookahead with the token to be matched:<code>(?=\p{Arabic})\p{N}</code><br>
<strong>Tempering the scope of a token</strong><br>
<!-- -->This use is similar to the last. Instead of removing characters from a class, it restricts the scope within which a token is allowed to match.  </p><p>For instance, suppose we want to match any character as long as it is not followed by <em>{END}</em>. Using a negative lookahead, we can use:<br>
<code>(?:(?!{END}).)*</code>Each . token is tempered by (?!{END}), which specifies that the dot cannot be the beginning of <em>{END}</em>. This technique is called <a href="https://www.rexegg.com/regex-quantifiers.html#tempered_greed" target="_blank" rel="noopener noreferrer"><em>tempered greedy token</em></a> on the <em>Quantifiers page</em>.  </p><p>Another technique is:<br>
<code>(?:[^{]++|{(?!END}))*+</code>On the left side of the alternation, <!-- -->[<!-- -->^{<!-- -->]<!-- -->++ matches characters that are not an opening brace. On the right side, {(?!END}) matches an opening brace that is not followed by <em>END}</em>. This technique appears in the <a href="https://www.rexegg.com/regex-quantifiers.html#explicit_greed" target="_blank" rel="noopener noreferrer"><em>Explicit Greedy Alternation</em></a> section of the <em>Quantifiers page</em>.  </p><p><strong>Delimiter</strong><br>
<!-- -->Do you have a string where you want to start matching all characters once the first instance of <em>#START#</em> is passed? No problem, just use a lookbehind to make a delimiter:<br>
<code>(?&lt;=#START#).*</code>After the lookbehind asserts that what immediately precedes the current position is <em>#START#</em>, the dot-star .<!-- -->*<!-- --> matches all the characters to the right.  </p><p>Or would you like to match all characters in a string up to, but not including the characters <em>#END#</em>? Make a delimiter using a lookahead:<br>
<code>.*?(?=#END#)</code><br>
<!-- -->You can, of course, combine the two:<br>
<code>(?&lt;=#START#).*?(?=#END#)</code><br>
<!-- -->See the page on boundaries for advice on building fancy <a href="https://www.rexegg.com/regex-boundaries.html#diy" target="_blank" rel="noopener noreferrer">DIY delimiters</a>.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#camelinsert" target="_blank" rel="noopener noreferrer">(direct link)</a><br>
<strong>Inserting Text at a Position</strong><br>
<!-- -->Someone gave you a file full of film titles in CamelCase, such as <em>HaroldAndKumarGoToWhiteCastle</em>. To make it easier to read, you want to insert a space at each position between a lowercase letter and an uppercase letter. This regex matches these exact positions:<br>
<code>(?&lt;=[a-z])(?=[A-Z])</code><br>
<!-- -->In your text editor&#x27;s regex replacement function, all you have to do is replace the matches space characters, and spaces be inserted in the right spot.  </p><p>This regex is what&#x27;s known as a &quot;zero-width match&quot; because it matches a position without matching any actual characters. How does it work? The lookbehind asserts that what immediately precedes the current position is a lowercase letter. And the lookahead asserts that what immediately follows the current position is an uppercase letter.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#camelsplit" target="_blank" rel="noopener noreferrer">(direct link)</a><br>
<strong>Splitting a String at a Position</strong><br>
<!-- -->We can use the exact same regex from the previous example to split the string <em>AppleOrangeBananaStrawberryPeach</em> into a list of fruits. Once again, the regex<br>
<code>(?&lt;=[a-z])(?=[A-Z])</code>matches the positions between a lowercase letter and an uppercase letter.  </p><p>In most languages, when you feed this regex to the function that uses a regex pattern to split strings, it returns an array of words.  </p><p>Note that Python&#x27;s <em>re</em> module does not split on zero-width matches—but the far superior <em>regex</em> module does.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#overlapping" target="_blank" rel="noopener noreferrer">(direct link)</a><br>
<strong>Finding Overlapping Matches</strong><br>
<!-- -->Sometimes, you need several matches within the same word. For instance, suppose that from a string such as <em>ABCD</em> you want to extract <em>ABCD</em>, <em>BCD</em>, <em>CD</em> and <em>D</em>. You can do it with this single regex:<br>
<code>(?=(\w+))</code>When you allow the engine to find all matches, all the substrings will be captured to Group 1  </p><p>How does this work?  </p><p>At the first position in the string (before the <em>A</em>), the engine starts the first match attempt. The lookahead asserts that what immediately follows the current position is one or more word characters, and captures these characters to Group 1. The lookahead succeeds, and so does the match attempt. Since the pattern didn&#x27;t match any actual characters (the lookahead only looks), the engine returns a zero-width match (the empty string). It also returns what was captured by Group 1: <em>ABCD</em>  </p><p>The engine then moves to the next position in the string and starts the next match attempt. Again, the lookahead asserts that what immediately follows that position is word characters, and captures these characters to Group 1. The match succeeds, and Group 1 contains <em>BCD</em>.  </p><p>The engine moves to the next position in the string, and the process repeats itself for <em>CD</em> then <em>D</em>.  </p><p>In .NET, which has infinite lookbehind, you can find overlapping matches from the other side of the string. For instance, on the same string <em>ABCD</em>, consider this pattern:<br>
<code>(?&lt;=(\w+))</code><br>
<!-- -->It will capture <em>A</em>, <em>AB</em>, <em>ABC</em> and <em>ABCD</em>. To achieve the same in an engine that doesn&#x27;t support infinite lookbehind, you would have to reverse the string, use the lookahead version <code>(?=(\w+))</code> then reverse the captures.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#zero_width" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="zero-width-matches">Zero-Width Matches<a href="#zero-width-matches" class="hash-link" aria-label="Direct link to Zero-Width Matches" title="Direct link to Zero-Width Matches">​</a></h2><p>As we&#x27;ve seen, a lookaround looks left or right but it doesn&#x27;t add any characters to the match to be returned by the regex engine. Likewise, an anchor such as ^ and a boundary such as <!-- -->\<!-- -->b can match at a given position in the string, but they do not add any characters to the match.  </p><p>Usually, lookaheads, lookbehinds, anchors and boundaries appear in patterns that contain tokens that do match characters, allowing the engine to return a matched string. For instance, in (?&lt;\=start<!-- -->_<!-- -->)<!-- -->\<!-- -->d+, the engine matches and returns some digits, but not the prefix _start<!-- -->_<!-- -->_  </p><p>However, if a pattern only contains lookarounds, anchors and boundaries, the engine may be able to match the pattern without matching any characters. The resulting match is called a <em>zero-width match</em> because it contains no characters.  </p><p>This can be a useful technique, and we have already seen some applications of zero-width matches in the section on <a href="https://www.rexegg.com/regex-lookarounds.html#uses" target="_blank" rel="noopener noreferrer">uses for lookarounds</a>. To bring them together under one heading, here are some of their main uses.  </p><p><strong>Validation</strong><br>
<!-- -->If you string several lookarounds in a row, you can validate that a string conforms to a set of rules, as in the <a href="https://www.rexegg.com/regex-lookarounds.html#password" target="_blank" rel="noopener noreferrer">password validation technique</a>.  </p><p>We saw that when you have n conditions, if you also want to match the string, you usually need n-1 lookarounds at the most as <a href="https://www.rexegg.com/regex-lookarounds.html#n-1conds" target="_blank" rel="noopener noreferrer">one condition can be removed</a> and used in the matching section of the pattern. But if all you want to do is validate, all the conditions can stay inside lookarounds, giving you a zero-width match.  </p><p><strong>Inserting</strong><br>
<!-- -->You can use a zero-width match regex to match a position in a string and insert text at that position. For instance, by matching (?m)^ (the beginning of a line in multiline mode) and replacing the match with // , you can add a prefix to every line of a file.  </p><p>Likewise, we saw how the zero-width pattern (?&lt;\=<!-- -->[<!-- -->a-z<!-- -->]<!-- -->)(?=<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->) allows you to <a href="https://www.rexegg.com/regex-lookarounds.html#camelinsert" target="_blank" rel="noopener noreferrer">insert characters in a CamelCase word</a>.  </p><p><strong>Splitting</strong><br>
<!-- -->We saw how the same zero-width pattern (?&lt;\=<!-- -->[<!-- -->a-z<!-- -->]<!-- -->)(?=<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->) allows you to <a href="https://www.rexegg.com/regex-lookarounds.html#camelsplit" target="_blank" rel="noopener noreferrer">split a CamelCase word</a> into its components.  </p><p><strong>Overlapping Matches</strong><br>
<!-- -->We saw how an unanchored lookaround that contains capture groups—such as (?=(<!-- -->\<!-- -->w+))—allows you to <a href="https://www.rexegg.com/regex-lookarounds.html#overlapping" target="_blank" rel="noopener noreferrer">match overlapping string segments</a>.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#position" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="positioning-the-lookaround">Positioning the Lookaround<a href="#positioning-the-lookaround" class="hash-link" aria-label="Direct link to Positioning the Lookaround" title="Direct link to Positioning the Lookaround">​</a></h2><p>Often, you have two options for positioning a lookaround: before the text to be matched, or after. Usually, one of the options is more efficient because it requires less work of the engine.  </p><p>To illustrate this, here are examples for each kind of lookaround. I borrowed them from the <a href="https://www.rexegg.com/regex-disambiguation.html#lookarounds" target="_blank" rel="noopener noreferrer">lookarounds section</a> of the main syntax page, where they are discussed in greater detail.  </p><p><strong>Lookahead</strong><br>
<!-- -->\<!-- -->d+(?= dollars) and (?=<!-- -->\<!-- -->d+ dollars)<!-- -->\<!-- -->d+ both match <em>100</em> in 100 dollars, but the first is more efficient because the engine needs to match <!-- -->\<!-- -->d+ only once.  </p><p><strong>Negative Lookahead</strong><br>
<!-- -->\<!-- -->d+(?! dollars) and (?!<!-- -->\<!-- -->d+ dollars)<!-- -->\<!-- -->d+ both match <em>100</em> in 100 pesos, but the first is more efficient because the engine needs to match <!-- -->\<!-- -->d+ only once.  </p><p><strong>Lookbehind</strong><br>
<!-- -->(?&lt;\=USD)<!-- -->\<!-- -->d{3} and <!-- -->\<!-- -->d{3}(?&lt;\=USD<!-- -->\<!-- -->d{3}) both match <em>100</em> in USD100, but the first is more efficient because the engine needs to match <!-- -->\<!-- -->d{3} only once.  </p><p><strong>Negative Lookbehind</strong><br>
<!-- -->(?&lt;!USD)<!-- -->\<!-- -->d{3} and <!-- -->\<!-- -->d{3}(?&lt;!USD<!-- -->\<!-- -->d{3}) both match <em>100</em> in JPY100, but the first is more efficient because the engine needs to match <!-- -->\<!-- -->d{3} only once.  </p><p>What may not be so clear is that each of these lookarounds can be used in two main ways: before the expression to be matched, or after it. These two ways have a slightly different feel. Please don&#x27;t obsess over the differences; rather, just cruise through these simple examples to become familiar with the types of effects you can achieve.  </p><p>When you compare each pair, the two methods have a different <em>feel</em>. The point of the examples is not to make you memorize &quot;the right position&quot;, but to expose you to those two basic feels. Once you&#x27;re familiar with them, you will naturally think of rewriting a lookaround that feels too heavy. With a bit of practice, the efficient way of positioning your lookarounds will probably come to you naturally.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#back_to_the_future" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="lookarounds-that-look-on-both-sides-back-to-the-future">Lookarounds that Look on Both Sides: Back to the Future<a href="#lookarounds-that-look-on-both-sides-back-to-the-future" class="hash-link" aria-label="Direct link to Lookarounds that Look on Both Sides: Back to the Future" title="Direct link to Lookarounds that Look on Both Sides: Back to the Future">​</a></h2><p>Suppose you want to match a two-digit number surrounded by underscores as in <!-- -->_<!-- -->12<!-- -->_<!-- --> but not the underscores.  </p><p>We have already seen three ways to do this:<br>
<!-- -->✽ You can match everything and capture the digits to Group 1: <!-- -->_<!-- -->(<!-- -->\<!-- -->d{2})<!-- -->_<br>
<!-- -->✽ You can use a lookbehind and a lookahead: (?&lt;\=<!-- -->_<!-- -->)<!-- -->\<!-- -->d{2}(?=<!-- -->_<!-- -->)<br>
<!-- -->✽ You can use <!-- -->\<!-- -->K to drop the first underscore from the match: <!-- -->_<!-- -->\<!-- -->K<!-- -->\<!-- -->d{2}(?=<!-- -->_<!-- -->)  </p><p>There is a fourth technique I&#x27;d like to introduce you to. I call it the &quot;back to the future lookbehind.&quot; There shouldn&#x27;t be any reason to use it on its own, but sometimes within an intricate pattern it may just what you need, so it&#x27;s nice to be familiar with it and add it to your repertoire.  </p><p>We can position our back-to-the-future lookbehind before or after the digits. Let&#x27;s start with the <em>before</em> version:<br>
<code>(?&lt;=_(?=\d{2}_))\d+</code><br>
<!-- -->Wowzy, what does this do? The lookbehind asserts that what immediately precedes the current position in the string is an underscore, then a position where the lookahead (?=<!-- -->\<!-- -->d{2}<!-- -->_<!-- -->) can assert that what immediately follows is two digits and an underscore.  </p><p>This is interesting for several reasons. First, we have a lookahead within a lookbehind, and even though we were supposed to look backwards, this lookahead jumps over the current position by matching the two digits and the trailing underscore. That&#x27;s acrobatic.  </p><p>Second, note that even though it looks complex, this is a fixed-width lookbehind (the width is one character, the underscore), so it should work in all flavors of lookbehind. (However, it does not work in Ruby as Ruby does not allow lookaheads and negative lookbehinds inside lookbehind.)  </p><p>Another interesting feature is how the notion of &quot;current position in the string&quot; is not the same for the lookbehind and for the lookahead. You&#x27;ll remember that <a href="https://www.rexegg.com/regex-lookarounds.html#stand_their_ground" target="_blank" rel="noopener noreferrer">lookarounds stand their ground</a>, so that after checking the assertion made by a lookaround, the engine hasn&#x27;t moved in the string. Are we breaking that rule?  </p><p>We&#x27;re not. In the string <em>10 <!-- -->_<!-- -->16<!-- -->_<!-- --> 20</em>, let&#x27;s say the engine has reached the position between the underscore and the <em>1</em> in <em>16</em>. The lookbehind makes an assertion about what can be matched at that position. When the engine exits the lookbehind, it is still standing in that same spot, and the token <!-- -->\<!-- -->d{2} can proceed to match the characters <em>16</em>.  </p><p>But within the lookbehind itself, we enter a different little world. You can imagine that outside that world the engine is red, and inside the little world of the lookbehind, there is another little engine which is yellow. That yellow engine keeps track of its own position in the string. In most engines (.NET proceeds differently), the yellow engine is initially dropped at a position in the string that is found by taking the red engine&#x27;s position and subtracting the width of the lookbehind, which is 1. The yellow engine therefore starts its work before the leading underscore. Within the lookbehind&#x27;s little world, after matching the underscore token, the yellow engine&#x27;s position in the string is between the underscore and the <em>1</em>. It is that position that the lookahead refers to when it asserts that at the current position in the string (according to the little world of the lookbehind and its yellow engine), what immediately follows is two digits and an underscore.  </p><p><strong>After the digits</strong><br>
<!-- -->Here is a second version where the &quot;back-to-the-future lookbehind&quot; comes after the digits:<br>
<code>\d+(?&lt;=_\d{2}(?=_))</code><br>
<!-- -->The lookbehind states: what immediately precedes this position in the string is an underscore and two digits, then a position where the lookahead (?=<!-- -->_<!-- -->) can assert that what immediately follows the current position in the string (according to the yellow engine and the lookbehind&#x27;s little world) is an underscore.  </p><p>This too is a fixed-width lookbehind (the width is three character, i.e. the leading underscore and the two digits), so it should work in all flavors of lookbehind except Ruby.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#compound" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="compound-lookahead-and-compound-lookbehind">Compound Lookahead and Compound Lookbehind<a href="#compound-lookahead-and-compound-lookbehind" class="hash-link" aria-label="Direct link to Compound Lookahead and Compound Lookbehind" title="Direct link to Compound Lookahead and Compound Lookbehind">​</a></h2><p>The <a href="https://www.rexegg.com/regex-lookarounds.html#back_to_the_future" target="_blank" rel="noopener noreferrer">back-to-the-future lookbehind</a> introduced us to what I call <em>compound lookarounds</em>, i.e., lookarounds that contain other lookarounds. You could also call them <em>nested lookarounds</em>, but for me the idea of compounding captures something more about the feel of working with these constructs.  </p><p>Let&#x27;s look at some examples.  </p><p><strong>Token followed by one character, but not more</strong><br>
<!-- -->How can you match a number that is followed by one underscore, but not more?  </p><p>You can use this:<br>
<code>\d+(?=_(?!_))</code>The lookahead asserts: what follows the current position in the string is one underscore, then a position where the negative lookahead (?!<!-- -->_<!-- -->) can assert that what follows is not an underscore. A less elegant variation would be <!-- -->\<!-- -->d+(?=(?!<!-- -->_<!-- -->_<!-- -->)<!-- -->_<!-- -->)  </p><p><strong>Token preceded by one character, but not more</strong><br>
<!-- -->How can you match a number that is preceded by one underscore, but not more?  </p><p>You can use this:<br>
<code>(?&lt;=(?&lt;!_)_)\d+</code>The lookbehind asserts: what precedes the current position in the string is a position where the negative lookbehind (?&lt;!<!-- -->_<!-- -->) can assert that what immediately precedes is not an underscore, then an underscore. A variation would be (?&lt;\=<!-- -->_<!-- -->(?&lt;!<!-- -->_<!-- -->_<!-- -->))<!-- -->\<!-- -->d+  </p><p><strong>Multiple Compounding</strong><br>
<!-- -->Needless to say, it won&#x27;t be long until you find occasions to add levels of compounding beyond the two we&#x27;ve just seen. But that quickly becomes obnoxious, and it becomes simpler to rearrange the regex. For instance, building on the previous pattern,<br>
<code>(?&lt;=(?&lt;!(?&lt;!X)_)_)\d+</code>matches a number that is precede by an underscore that is not preceded by an underscore unless that underscore is preceded by an <em>X</em>.  </p><p>In .NET, PCRE, Java and Ruby, this could be simplified to (?&lt;\=(?&lt;!<!-- -->_<!-- -->)<!-- -->_<!-- -->|X<!-- -->_<!-- -->_<!-- -->)<!-- -->\<!-- -->d+<br>
<!-- -->In Perl and Python, you could use (?:(?&lt;\=(?&lt;!<!-- -->_<!-- -->)<!-- -->_<!-- -->)|(?&lt;\=X<!-- -->_<!-- -->_<!-- -->))<!-- -->\<!-- -->d+  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#atomic" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="the-engine-doesnt-backtrack-into-lookarounds">The Engine Doesn&#x27;t Backtrack into Lookarounds…<a href="#the-engine-doesnt-backtrack-into-lookarounds" class="hash-link" aria-label="Direct link to The Engine Doesn&#x27;t Backtrack into Lookarounds…" title="Direct link to The Engine Doesn&#x27;t Backtrack into Lookarounds…">​</a></h2><p>…because they&#x27;re atomic</p><p>Here&#x27;s a fun regex task. You have a string like this:<br>
<!-- -->_<!-- -->rabbit <!-- -->_<!-- -->dog <!-- -->_<!-- -->mouse DIC🐱dog:mouse<br>
<!-- -->The <em>DIC</em> section at the end contains a list of allowed animals. Our job is to match all the <em>_<!-- -->tokens</em> named after an allowed animal. Therefore, we expect to match <em>_<!-- -->dog</em> and <em>_<!-- -->mouse</em>. A lookaround helps us do this:  </p><p><code>_(\w+)\b(?=.*:\1\b)</code><br>
<!-- -->After matching the underscore, we capture a word to Group 1. Then the lookahead (?=.<!-- -->*<!-- -->:<!-- -->\<!-- -->1<!-- -->\<!-- -->b) asserts what follows the current position in the string is zero or more characters, then a colon, then the word captured to Group 1. As hoped, this matches both <em>_<!-- -->dog</em> and <em>_<!-- -->mouse</em>.  </p><p>Now suppose we try a &quot;reversed&quot; approach:  </p><p><code>_(?=.*:(\w+)\b)\1\b</code><br>
<!-- -->This only matches <em>_<!-- -->mouse</em>. Why?  </p><p>First let&#x27;s try to understand what this regex hopes to accomplish. It may not be that obvious, but it illustrates an important feature of lookarounds.  </p><p>After the engine matches the underscore, the lookahead (?=.<!-- -->*<!-- -->:(<!-- -->\<!-- -->w+)<!-- -->\<!-- -->b) asserts that what follows the current position in the string is any number of characters, then a colon, then a word (captured to Group 1). After passing that assertion, the back-reference <!-- -->\<!-- -->1 matches what was captured into Group 1.  </p><p>Let&#x27;s see how this works out. Remember that our string is<br>
<!-- -->_<!-- -->rabbit <!-- -->_<!-- -->dog <!-- -->_<!-- -->mouse DIC🐱dog:mouse<br>
<!-- -->After the underscore that precedes <em>rabbit</em>, we expect the lookahead to fail because there is no <em>rabbit</em> in the <em>DIC</em> section—and it does. The next time we match an underscore is before <em>dog</em>. At that stage, inside the lookahead (?=.<!-- -->*<!-- -->:(<!-- -->\<!-- -->w+)<!-- -->\<!-- -->b), the dot-star shoots down to the end of the string, then backtracks just far enough to allow the colon to match, after which the word <em>mouse</em> is matched and captured to Group 1. The lookahead succeeds. The next token <!-- -->\<!-- -->1 tries to match <em>mouse</em>, but the next character in the string is the <em>d</em> from <em>dog</em>, so the token fails. At this stage, having learned everything about backtracking, we might assume that the regex engine allows the dot-star to backtrack even more inside the lookahead, up to the previous colon, which would then allow (<!-- -->\<!-- -->w+) to match and capture <em>mouse</em>. Then the back-reference <!-- -->\<!-- -->1 would match <em>mouse</em>, and the engine would return a successful match.  </p><p>However, it does not work that way. Once the regex engine has left a lookaround, it will not backtrack into it if something fails somewhere down the pattern. On a logical level, that is because the official point of a lookaround is to return one of two values: true or false. Once a lookahead evaluates to true at a given position in the string, it is always true. From the engine&#x27;s standpoint, there is nothing to backtrack. What would be the point—since the only other available value is false, and that would fail the pattern?  </p><p>The fact that the engine will not backtrack into a lookaround means that it is an <a href="https://www.rexegg.com/regex-disambiguation.html#atomic" target="_blank" rel="noopener noreferrer">atomic block</a>. This property of lookarounds will rarely matter, but if someday, in the middle of building an intricate pattern, a lookahead refuses to cooperate… This may be the reason.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#width" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="fixed-width-constrained-width-and-infinite-width-lookbehind">Fixed-Width, Constrained-Width and Infinite-Width Lookbehind<a href="#fixed-width-constrained-width-and-infinite-width-lookbehind" class="hash-link" aria-label="Direct link to Fixed-Width, Constrained-Width and Infinite-Width Lookbehind" title="Direct link to Fixed-Width, Constrained-Width and Infinite-Width Lookbehind">​</a></h2><p>In strings such as <em>123456<!-- -->_<!-- -->ORANGE abc12<!-- -->_<!-- -->APPLE</em>, suppose you are interested in matching uppercase words, provided they are preceded by a prefix composed of digits and an underscore character. Therefore, in this string, you want to match <em>ORANGE</em> but not <em>APPLE</em>.  </p><p>It&#x27;s worth remembering that in most regex flavors (.NET is one of the few exceptions), the following pattern is invalid:  </p><p><code>(?&lt;=\b\d+_)[A-Z]+</code><br>
<!-- -->That is because the width of the text matched by the token <!-- -->\<!-- -->d+ can be anything. Most engines require the width of the subexpression within a lookbehind to be known in advance, as in (?&lt;\=<!-- -->\<!-- -->d{3})  </p><p>Some engines allow the width of the subexpression within a lookbehind to take various pre-determined values found on the various sides of an alternation, as in (?&lt;\=0|128|<!-- -->\<!-- -->d{6}). Yet others allow the width to vary within a pre-determined range, as in (?&lt;\=d{2,6})  </p><p>For details of what kinds of widths various engines allow in a lookbehind, see the <a href="https://www.rexegg.com/regex-disambiguation.html#lookbehind_width" target="_blank" rel="noopener noreferrer">Lookbehind: Fixed-Width / Constrained Width / Infinite Width</a> section of the main syntax page. To honor the winners, I&#x27;ll just repeat here that the only two programming-language flavors that support infinite-width lookbehind are .NET (C#, VB.NET, …) and Matthew Barnett&#x27;s <a href="https://pypi.python.org/pypi/regex" target="_blank" rel="noopener noreferrer"><em>regex</em> module</a> for Python. I&#x27;ve also implemented an <a href="https://www.rexegg.com/pcre-callouts.html#infinite_lb" target="_blank" rel="noopener noreferrer">infinite lookbehind demo for PCRE</a>.  </p><p><strong>Capture Group Inside Variable Lookbehind: Difference between Java and .NET</strong><br>
<!-- -->Both Java and .NET allow this pattern:<br>
<code>(?&lt;=(\d{1,5}))Z</code><br>
<!-- -->.NET allows it because it supports infinite-width lookbehind. Java allows it because it supports lookbehind whose width falls within a defined range. However, they operate differently. As a result, against the string <em>123Z</em>, this pattern will return different Group 1 captures in the two engines.  </p><p>✽ Java captures <em>3</em> to Group 1. The engine sees that the width of the string to be matched inside the lookbehind must fall between one and five characters. Java tries all the possible fixed-width patterns in the range, from the shortest to the longest, until one succeeds. The shortest possible fixed-width pattern is (?&lt;\=(<!-- -->\<!-- -->d{1})). The engine temporarily skips back one character in the string, tries to match <!-- -->\<!-- -->d{1} and succeeds. The lookaround succeeds, and Group 1 contains <em>3</em>.  </p><p>✽ .NET captures <em>123</em> to Group 1. The .NET engine has a far more efficient way of processing variable-width lookbehinds. Instead of trying multiple fixed-width patterns starting at points further and further back in the string, .NET reverses the string as well as the pattern inside the lookbehind, then attempts to match that single pattern on the reversed string. Therefore, in <em>123Z</em>, to try the lookbehind at the point before <em>Z</em>, it reverses the portion of string to be tested from <em>123</em> to <em>321</em>. Likewise, the lookbehind (?&lt;\=(<!-- -->\<!-- -->d{1,5})) is flipped into the lookahead (?=(<!-- -->\<!-- -->d{1,5})). <!-- -->\<!-- -->d{1,5} matches <em>321</em>. Reversing that string, Group 1 contains <em>123</em>. To only capture <em>3</em> as in Java, you would have to make the quantifier lazy: <code>(?&lt;=(\d{1,5}?))Z</code>  </p><p>✽ Like .NET, the <em>regex</em> alternate regular expressions module for Python captures <em>123</em> to Group 1.  </p><p><strong>Workarounds</strong><br>
<!-- -->There are two main workarounds to the lack of support for variable-width (or infinite-width) lookbehind:  </p><p>✽ Capture groups.<br>
<!-- -->Instead of (?&lt;\=<!-- -->\<!-- -->b<!-- -->\<!-- -->d+<!-- -->_<!-- -->)<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->+ , you can use <!-- -->\<!-- -->b<!-- -->\<!-- -->d+<!-- -->_<!-- -->(<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->+), which matches the digits and underscore you don&#x27;t want to see, then matches and captures to Group 1 the uppercase text you want to inspect. This will work in all major regex flavors.  </p><p>✽ The <!-- -->\<!-- -->K &quot;keep out&quot; verb, which is available in Perl, PCRE (C, PHP, R…), Ruby 2+ and Python<!-- -->\<!-- -->&#x27;s alternate <a href="https://pypi.python.org/pypi/regex" target="_blank" rel="noopener noreferrer"><em>regex</em> engine</a>.<br>
<!-- -->\<!-- -->K tells the engine to drop whatever it has matched so far from the match to be returned. Instead of (?&lt;\=<!-- -->\<!-- -->b<!-- -->\<!-- -->d+<!-- -->_<!-- -->)<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->+, you can therefore use <!-- -->\<!-- -->b<!-- -->\<!-- -->d+<!-- -->_<!-- -->\<!-- -->K<!-- -->[<!-- -->A-Z<!-- -->]<!-- -->+  </p><p>Compared with lookbehinds, both the <!-- -->\<!-- -->K and capture group workarounds have limitations:  </p><p>✽ When you look for multiple matches in a string, at the starting position of each match attempt, a lookbehind can inspect the characters behind the current position in the string. Therefore, against <em>123</em>, the pattern <code>(?&lt;=\d)\d</code> (match a digit preceded by a digit) will match both <em>2</em> and <em>3</em>. In contrast, <em>\<!-- -->d<!-- -->\<!-- -->K<!-- -->\<!-- -->d</em> can only match <em>2</em>, as the starting position after the first match is immediately before the <em>3</em>, and there are not enough digits left for a second match. Likewise, <!-- -->\<!-- -->d(<!-- -->\<!-- -->d) can only capture <em>2</em>.  </p><p>✽ With lookbehinds, you can impose multiple conditions (similar to our <a href="https://www.rexegg.com/regex-lookarounds.html#password" target="_blank" rel="noopener noreferrer">password validation technique</a>) by using multiple lookbehinds. For instance, to match a digit that is preceded by a lower-case Greek letter, you can use <code>(?&lt;=\p{Ll})(?&lt;=\p{Greek})\d</code>. The first lookbehind (?&lt;\=<!-- -->\<!-- -->p{Ll}) ensures that the character immediately to the left is a lower-case letter, and the second lookbehind (?&lt;\=<!-- -->\<!-- -->p{Greek}) ensures that the character immediately to the left belongs to the Greek script. With the workarounds, you could use <!-- -->\<!-- -->p{Greek}<!-- -->\<!-- -->K<!-- -->\<!-- -->d to match a digit preceded by a character in the Greek script (or <!-- -->\<!-- -->p{Greek}(<!-- -->\<!-- -->d) to capture it), but you cannot impose a second condition. To get over this limitation, you could capture the Greek character and use a second regex to check that it is a lower-case letter.  </p><p><a href="https://www.rexegg.com/regex-lookarounds.html#anchor" target="_blank" rel="noopener noreferrer">(direct link)</a>  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="lookarounds-usually-want-to-be-anchored">Lookarounds (Usually) Want to be Anchored<a href="#lookarounds-usually-want-to-be-anchored" class="hash-link" aria-label="Direct link to Lookarounds (Usually) Want to be Anchored" title="Direct link to Lookarounds (Usually) Want to be Anchored">​</a></h2><p>Let&#x27;s imagine we want to match a string consisting of one word, provided it contains at least one digit. This pattern offers a reasonable solution—one of several:<br>
<code>\A(?=\D*\d)\w+\z</code><br>
<!-- -->The <a href="https://www.rexegg.com/regex-anchors.html#A" target="_blank" rel="noopener noreferrer">\<!-- -->A anchor</a> asserts that the current position is the beginning of the string. The lookahead (?=<!-- -->\<!-- -->D<!-- -->*<!-- -->\<!-- -->d) asserts that at the current position (which is still the beginning of the string), we can match zero or more non-digits, then one digit. Next, <!-- -->\<!-- -->w+ matches our word. Finally, the <a href="https://www.rexegg.com/regex-anchors.html#z" target="_blank" rel="noopener noreferrer">\<!-- -->z anchor</a> asserts that the current position is the end of the string.  </p><p>Now consider what happens when we forget the anchor <!-- -->\<!-- -->A and use (?=<!-- -->\<!-- -->D<!-- -->*<!-- -->\<!-- -->d)<!-- -->\<!-- -->w+<!-- -->\<!-- -->z. To make our oversight seem less severe, let&#x27;s assume we know that our string always contains an uninterrupted string of word characters. This guarantees that if we find a match, it will have to be the right one—at the beginning of the string, as we wanted. So what&#x27;s the problem?  </p><p>Suppose we use our regex on a string composed of one hundred characters <em>V</em>. Since the string doesn&#x27;t contain a single digit, you and I can immediately see that the regex must fail. Let&#x27;s see how fast the engine comes to the same conclusion.  </p><p>As always, the engine begins by trying to match the pattern at the first position in the string. Starting with the first token (?=<!-- -->\<!-- -->D<!-- -->*<!-- -->\<!-- -->d), it tries to assert that at the current position, i.e. the beginning of the string, it can match zero or more non-digits, then one digit. Within the subexpression, the <!-- -->\<!-- -->D<!-- -->*<!-- --> matches all the <em>V</em> characters. The engine then tries to match a digit, but since we have reached the end of the string, that fails.  </p><p>If we&#x27;re using a smart engine such as PCRE, at this stage the engine fails the lookaround for this first match attempt. That&#x27;s because before starting the match attempt, the engine has studied the pattern and noticed that the <!-- -->\<!-- -->D and <!-- -->\<!-- -->d tokens are mutually exclusive, and it has turned the <!-- -->*<!-- --> quantifier into a possessive quantifier <!-- -->*<!-- -->+, a process known to PCRE as <em>auto-possessification</em> (see <a href="https://www.rexegg.com/regex-lookarounds.html#atomic" target="_blank" rel="noopener noreferrer">footnote</a>).  </p><p>A less clever engine will backtrack, giving up all the <!-- -->\<!-- -->D characters it has matched one by one, each time attempting to match a <!-- -->\<!-- -->d after giving up a <!-- -->\<!-- -->D. Eventually, the engine runs out of characters to backtrack, and the lookahead fails.  </p><p>Once the engine understands that the lookahead must fail (whether it comes to this conclusion cleverly or clumsily), it gives up on the entire first match attempt. Next, as always in such cases, the engine moves to the next position in the string (past the first <em>V</em>) and starts a new match attempt. Again, the <!-- -->\<!-- -->D<!-- -->*<!-- --> eats up all the <em>V</em> characters—although this time, there are only 99 of them. Again, the lookahead fails, either fast if the engine is smart, or, more likely, after backtracking all the way back to the starting position.  </p><p>After failing a second time, the engine moves past the second <em>V</em>, starts a new match attempt, and fails… And so on, all the way to the end of the string.  </p><p>Because the pattern is not anchored at the beginning of the string, at each match attempt, the engine checks whether the lookahead matches at the current position. In doing so, in the best case, it matches 100 <em>V</em> characters, then 99 on the second attempt, and so on—so it needs about 5000 steps before it can see that the pattern will never match. In the more usual case, the engine needs to backtrack and try the <!-- -->\<!-- -->d at each position, adding two steps at each <em>V position</em>. Altogether, it needs about 15,000 steps before it can see that the pattern will never match.  </p><p>In contrast, with the original anchored pattern <!-- -->\<!-- -->A(?=<!-- -->\<!-- -->D<!-- -->*<!-- -->\<!-- -->d)<!-- -->\<!-- -->w+<!-- -->\<!-- -->z, after the engine fails the first match attempt, each of the following match attempts at further positions in the string fail instantly, because the <!-- -->\<!-- -->A fails before the engine gets to the lookahead. In the best case, the engine takes about 200 steps to fail (100 steps to match all the <em>V</em> characters, then one step at each of the further match attempts.) In the more usual case, the engine takes about 400 steps to fail (300 steps on the first match attempt, then one step at each of the further match attempts.)  </p><p>Needless to say, the ratio of (15,000 / 400) steps is the kind of performance hit we try to avoid in computing. This makes a solid case for helping the engine along by minimizing the number of times lookaheads must be attempted, either by using <a href="https://www.rexegg.com/regex-anchors.html" target="_blank" rel="noopener noreferrer">anchors</a> such as ^ and <!-- -->\<!-- -->A, or by matching literal characters immediately before the lookahead.  </p><p><strong>One Exception: Overlapping Matches</strong><br>
<!-- -->There are times when we do want the engine to attempt the lookahead at every single position in the string. Usually, the purpose of such a maneuver is to match a number of overlapping substrings. For instance, against the string word, if the regex (?=(<!-- -->\<!-- -->w+)) is allowed to match repeatedly, it will match four times, and each match will capture a different string to Group 1: <em>word</em>, <em>ord</em>, <em>rd</em>, then <em>d</em>. The section on <a href="https://www.rexegg.com/regex-lookarounds.html#overlapping" target="_blank" rel="noopener noreferrer">overlapping matches</a> explains how this works.  </p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="footnotes">Footnotes<a href="#footnotes" class="hash-link" aria-label="Direct link to Footnotes" title="Direct link to Footnotes">​</a></h2><p><strong>Atomic tweak</strong><br>
<!-- -->The <a href="https://www.rexegg.com/regex-disambiguation.html#atomic" target="_blank" rel="noopener noreferrer">atomic</a> variation (?<!-- -->&gt;<!-- -->[<!-- -->^a-z<!-- -->]<!-- -->*<!-- -->)<!-- -->[<!-- -->a-z<!-- -->]<!-- --> or <a href="https://www.rexegg.com/regex-quantifiers.html#possessive" target="_blank" rel="noopener noreferrer">possessive</a> version <!-- -->[<!-- -->^a-z<!-- -->]<!-- -->*<!-- -->+<!-- -->[<!-- -->a-z<!-- -->]<!-- --> are tweaks that ensure that if the engine fails to find the lowercase letter, it won&#x27;t &quot;stupidly&quot; backtrack, giving up the non-lowercase letters one by one to see if a lowercase letter might fit at that stage.  </p><p>Note that before they start matching, some engines notice the mutually exclusive character of <!-- -->[<!-- -->a-z<!-- -->]<!-- --> and its counterclass and automatically make the <!-- -->*<!-- --> quantifier possessive for you. This optimization is what PCRE calls <em>auto-possessification</em>. It allows you to turn it off with the <a href="https://www.rexegg.com/regex-modifiers.html#pcre" target="_blank" rel="noopener noreferrer">Special Start-of-Pattern Modifier</a> (<!-- -->*<!-- -->NO<!-- -->_<!-- -->AUTO<!-- -->_<!-- -->POSSESS)—but why would you ever want to?</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/个人资料/0、引言"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">0、引言</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/个人资料/th"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">处置的定义</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#lookahead-example-simple-password-validation" class="table-of-contents__link toc-highlight">Lookahead Example: Simple Password Validation</a></li><li><a href="#the-order-of-lookaheads-doesnt-matter-almost" class="table-of-contents__link toc-highlight">The Order of Lookaheads Doesn&#39;t Matter… Almost</a></li><li><a href="#lookarounds-stand-their-ground" class="table-of-contents__link toc-highlight">Lookarounds Stand their Ground</a></li><li><a href="#various-uses-for-lookarounds" class="table-of-contents__link toc-highlight">Various Uses for Lookarounds</a></li><li><a href="#zero-width-matches" class="table-of-contents__link toc-highlight">Zero-Width Matches</a></li><li><a href="#positioning-the-lookaround" class="table-of-contents__link toc-highlight">Positioning the Lookaround</a></li><li><a href="#lookarounds-that-look-on-both-sides-back-to-the-future" class="table-of-contents__link toc-highlight">Lookarounds that Look on Both Sides: Back to the Future</a></li><li><a href="#compound-lookahead-and-compound-lookbehind" class="table-of-contents__link toc-highlight">Compound Lookahead and Compound Lookbehind</a></li><li><a href="#the-engine-doesnt-backtrack-into-lookarounds" class="table-of-contents__link toc-highlight">The Engine Doesn&#39;t Backtrack into Lookarounds…</a></li><li><a href="#fixed-width-constrained-width-and-infinite-width-lookbehind" class="table-of-contents__link toc-highlight">Fixed-Width, Constrained-Width and Infinite-Width Lookbehind</a></li><li><a href="#lookarounds-usually-want-to-be-anchored" class="table-of-contents__link toc-highlight">Lookarounds (Usually) Want to be Anchored</a></li><li><a href="#footnotes" class="table-of-contents__link toc-highlight">Footnotes</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><a href="https://nav.wiki-power.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">友链 &amp; 导航站<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><span class="footer__link-separator">·</span><a href="http://digest.wiki-power.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">书摘<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><span class="footer__link-separator">·</span><a href="https://github.com/linyuxuanlin/File-host" target="_blank" rel="noopener noreferrer" class="footer__link-item">资源仓库<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.9ccc41ac.js"></script>
<script src="/assets/js/main.efaa865f.js"></script>
</body>
</html>